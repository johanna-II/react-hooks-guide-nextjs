// 한국어 원본 텍스트 맵핑
export const koreanTexts: Record<string, string> = {
  // Hero section
  'hero.title': 'HOOKS',
  'hero.subtitle': 'React의 <span>미래</span>를 만나다',
  'hero.description': 'React Hooks의 모든 것을 배우고, React 19의 혁신적인 기능들을 체험해보세요. 실시간 데모와 함께하는 인터랙티브 학습 가이드입니다.',
  
  // Navigation
  'navigation.home': '홈',
  'navigation.hooks': 'React Hooks',
  'navigation.optimization': '최적화',
  'navigation.patterns': '고급 패턴',
  
  // Common
  'common.loading': '로딩 중...',
  'common.error': '오류가 발생했습니다',
  'common.retry': '다시 시도',
  'common.close': '닫기',
  'common.open': '열기',
  'common.save': '저장',
  'common.cancel': '취소',
  'common.delete': '삭제',
  'common.edit': '수정',
  'common.add': '추가',
  'common.search': '검색',
  'common.filter': '필터',
  'common.sort': '정렬',
  'common.reset': '초기화',
  'common.submit': '제출',
  'common.back': '뒤로',
  'common.next': '다음',
  'common.previous': '이전',
  'common.confirm': '확인',
  'common.yes': '예',
  'common.no': '아니오',
  
  // Guide
  'guide.completeGuide': '완벽 가이드',
  'guide.hooksRules': '📋 Hooks 사용 규칙',
  'guide.whyHooksNeeded': '🚀 Hooks가 필요한 이유',
  'guide.beginnerTitle': '🎯 초보자를 위한 React Hooks 완벽 가이드',
  'guide.whatIsHook': 'Hook이란?',
  'guide.whatIsHookDesc': 'Hook은 함수형 컴포넌트에서 React의 상태와 생명주기 기능을 사용할 수 있게 해주는 함수입니다. 클래스 컴포넌트 없이도 React의 모든 기능을 활용할 수 있게 되었습니다.',
  'guide.whyUseHooks': '왜 Hook을 사용할까?',
  'guide.whyUseHooksDesc': 'Hook을 사용하면 컴포넌트 간에 상태 로직을 재사용하기 쉽고, 복잡한 컴포넌트를 더 쉽게 이해할 수 있습니다.',
  'guide.hookAdvantages': 'Hook의 장점',
  'guide.hookAdvantagesDesc': '클래스 컴포넌트의 this 바인딩 문제가 없고, 컴포넌트를 더 작은 함수로 나누어 테스트하기 쉽습니다.',
  'guide.hookAdvantagesDesc.short': '컴포넌트를 더 작은 함수로 나누어 테스트하기 쉽습니다.',
  
  // Hooks
  'hooks.useState.title': 'useState',
  'hooks.useState.description': '컴포넌트의 상태를 관리하는 가장 기본적인 Hook입니다.',
  'hooks.useState.descriptionDetail': '컴포넌트에 상태를 추가하는 Hook입니다.',
  'hooks.useEffect.title': 'useEffect',
  'hooks.useEffect.description': '부수 효과를 수행하고 생명주기를 관리합니다.',
  'hooks.useEffect.descriptionDetail': '컴포넌트의 생명주기와 관련된 작업을 처리하는 Hook입니다.',
  'hooks.useCallback.title': 'useCallback',
  'hooks.useCallback.description': '함수를 메모이제이션하여 불필요한 재생성을 방지합니다.',
  'hooks.useCallback.descriptionDetail': '함수를 메모이제이션하여 불필요한 리렌더링을 방지합니다.',
  'hooks.useMemo.title': 'useMemo',
  'hooks.useMemo.description': '계산 비용이 높은 값을 메모이제이션합니다.',
  'hooks.useMemo.descriptionDetail': '계산 결과를 메모이제이션하여 성능을 최적화합니다.',
  'hooks.useRef.title': 'useRef',
  'hooks.useRef.description': 'DOM 요소나 값에 대한 참조를 유지합니다.',
  'hooks.useRef.descriptionDetail': 'DOM 요소에 직접 접근하거나 값을 저장하는 Hook입니다.',
  'hooks.codeExample': '코드 예시',
  'hooks.realTimeDemo': '실시간 데모',
  'hooks.typeSomething': '무언가 입력해보세요...',
  'hooks.effectRunCount': 'Effect 실행 횟수',
  'hooks.browserTabNotice': '브라우저 탭 제목이 변경되는 것을 확인하세요!',
  'hooks.clickToFocus': '버튼을 클릭해서 포커스하세요...',
  'hooks.focusCount': 'Focus 횟수',
  'hooks.renderCount': '렌더링 횟수',
  'hooks.optimizationTip': 'useCallback으로 함수가 메모이제이션되어 불필요한 리렌더링을 방지합니다!',
  'hooks.valueA': '값 A',
  'hooks.valueB': '값 B',
  'hooks.calculationResult': '계산 결과',
  'hooks.calculationCount': '계산 실행 횟수',
  'hooks.memoTip': 'A나 B가 변경될 때만 계산이 실행됩니다!',
  
  // Demo
  'demo.title': '데모',
  'demo.description': '실제 동작하는 예제를 확인해보세요',
  'demo.runDemo': '데모 실행',
  'demo.viewCode': '코드 보기',
  'demo.result': '결과',
  
  // Mobile
  'mobile.startButton': '시작하기',
  'mobile.swipeHint': '또는 좌측으로 스와이프',
  'mobile.beginnerHooks': '초보자를 위한 React Hooks',
  'mobile.meetFuture': 'React의 미래를 만나다',
  'mobile.learnEverything': 'React Hooks의 모든 것을 배우고, React 19의 혁신적인 기능들을 체험해보세요.',
  
  // Form
  'form.title': 'Form Actions 데모',
  'form.description': '이 데모는 React 19의 새로운 Form Actions 기능을 시뮬레이션합니다. 실제 Form Actions에서는 useActionState와 useFormStatus를 사용합니다.',
  'form.formActions.code': 'Form Actions 코드',
  'form.formActions.example': 'React 19 사용 예제입니다.',
  'form.react19.benefits': 'React 19의 장점',
  'form.react19.comparison': '기존 방식과의 차이',
  'form.benefits.autoReset': '자동 폼 리셋',
  'form.benefits.errorHandling': '내장 에러 처리',
  'form.benefits.pendingState': 'Pending 상태 자동 관리',
  'form.benefits.optimistic': '낙관적 업데이트 지원',
  'form.comparison.noUseState': 'useState + useEffect 불필요',
  'form.comparison.noManualError': '수동 에러 처리 제거',
  'form.comparison.simpleState': '복잡한 상태 관리 단순화',
  'form.comparison.betterUX': '더 나은 사용자 경험',
  'form.comment.actionStateUsage': '이름과 이메일을 모두 입력해주세요.',
  'form.comment.submitFailure': '제출에 실패했습니다. 다시 시도해주세요.',
  'form.submit.preparing': '제출 중...',
  'form.submit.button': '폼 제출하기',
  'form.submitAria': '폼 제출',
  'form.name': '이름',
  'form.email': '이메일',
  'form.message': '메시지',
  'form.namePlaceholder': '이름을 입력하세요',
  'form.emailPlaceholder': '이메일을 입력하세요',
  'form.messagePlaceholder': '메시지를 입력하세요',
  'form.submit': '제출',
  'form.submitting': '제출 중...',
  'form.successMessage': '폼이 성공적으로 제출되었습니다!',
  'form.errorMessage': '필수 필드를 모두 입력해주세요.',
  'form.required': '필수',
  
  // Why Hooks
  'whyHooks.title': 'Hooks가 필요한 이유',
  'whyHooks.wrapperHell.title': 'Wrapper Hell 해결',
  'whyHooks.wrapperHell.desc': 'HOC와 Render Props로 인한 복잡한 component tree를 단순화합니다.',
  'whyHooks.wrapperHell.detail': '마치 러시아 인형처럼 겹겹이 싸인 코드를 풀어서 깔끕하게 정리해줍니다.',
  'whyHooks.lifecycleSimplification.title': 'Lifecycle 단순화',
  'whyHooks.lifecycleSimplification.desc': '여러 lifecycle method에 흩어진 logic을 useEffect 하나로 통합합니다.',
  'whyHooks.lifecycleSimplification.detail': '출생, 성장, 소멸 같은 복잡한 생명주기를 하나의 함수로 간단하게 관리합니다.',
  'whyHooks.thisRemoval.title': 'this 제거',
  'whyHooks.thisRemoval.desc': 'JavaScript의 혼란스러운 this binding 없이 깔끕한 functional component를 작성합니다.',
  'whyHooks.thisRemoval.detail': '누가 "나"인지 헷갈리지 않고 명확하게 코드를 작성할 수 있습니다.',
  'whyHooks.logicReuse.title': 'Logic 재사용',
  'whyHooks.logicReuse.desc': 'Custom Hook으로 상태 관련 로직을 쉽게 재사용하고 공유할 수 있습니다.',
  'whyHooks.logicReuse.detail': '레고 블록처럼 필요한 기능을 조립하고, 다른 프로젝트에서도 똑같이 사용할 수 있습니다.',
  'whyHooks.typescriptFriendly.title': 'TypeScript 친화적',
  'whyHooks.typescriptFriendly.desc': '타입 추론과 제네릭을 활용하여 타입 안전한 코드를 작성할 수 있습니다.',
  'whyHooks.typescriptFriendly.detail': '런타임 에러를 컴파일 타임에 미리 잡아내어 더욱 안정적인 애플리케이션을 구축할 수 있습니다.',
  'whyHooks.performanceOptimization.title': '성능 최적화',
  'whyHooks.performanceOptimization.desc': 'React.memo, useMemo, useCallback으로 불필요한 리렌더링을 방지합니다.',
  'whyHooks.performanceOptimization.detail': '메모이제이션을 통해 계산 결과를 재사용하여 사용자 경험을 크게 향상시킵니다.',
  'whyHooks.items.stateful.title': '상태 로직 재사용',
  'whyHooks.items.stateful.desc': 'HOCs나 render props 없이 컴포넌트 간 상태 로직을 쉽게 공유',
  'whyHooks.items.simpleComponents.title': '더 단순한 컴포넌트',
  'whyHooks.items.simpleComponents.desc': '함수형 컴포넌트는 클래스 컴포넌트보다 이해와 테스트가 쉽다',
  'whyHooks.items.bundleSize.title': '번들 크기 개선',
  'whyHooks.items.bundleSize.desc': '함수형 컴포넌트는 클래스 컴포넌트보다 미니파이가 효율적',
  'whyHooks.items.noBinding.title': '바인딩 문제 해결',
  'whyHooks.items.noBinding.desc': '이벤트 핸들러에서 \'this\' 바인딩을 걱정할 필요가 없다',
  'whyHooks.items.composition.title': '더 나은 조합',
  'whyHooks.items.composition.desc': 'Hook을 통해 하나의 컴포넌트를 더 작은 함수로 분할 가능',
  'whyHooks.items.futureReady.title': '미래를 위한 준비',
  'whyHooks.items.futureReady.desc': 'React 팀은 새로운 기능을 함수형 컴포넌트에 집중',
  
  // Optimization Demos
  'optimization.metrics.title': '주요 성능 메트릭',
  'optimization.metrics.description': '성능 최적화를 이해하기 위해 알아야 할 핵심 지표들을 설명합니다.',
  'optimization.renderCount.title': 'Render Count 최적화',
  'optimization.renderCount.description': '불필요한 렌더링을 방지하여 성능을 향상시킵니다.',
  'optimization.renderCount.memo.desc': 'props가 변경되지 않으면 컴포넌트를 다시 렌더링하지 않습니다.',
  'optimization.renderCount.improvement': '번의 불필요한 렌더링 방지!',
  'optimization.renderCount.test': '테스트해보세요!',
  
  'optimization.executionTime.title': 'Execution Time 최적화',
  'optimization.executionTime.description': '비용이 높은 계산을 메모이제이션합니다.',
  'optimization.executionTime.memo.desc': '의존성이 변경되지 않으면 계산을 다시 하지 않습니다.',
  'optimization.executionTime.improvement': '% 성능 향상!',
  'optimization.executionTime.recalculationEveryTime': '매번 recalculation',
  'optimization.executionTime.cachedResults': '캐시된 결과 사용',
  'optimization.executionTime.calculatePrime': 'Calculate Prime',
  'optimization.executionTime.calculateNow': '지금 계산하기',
  'optimization.executionTime.calculationTime': 'milliseconds',
  'optimization.executionTime.slowCalculation': '큰 소수 판별을 매번 다시 계산 (느림)',
  'optimization.executionTime.fastCalculation': '한 번 계산하고 캐시 사용 (빠름)',
  'optimization.executionTime.performanceComparisonResult': '성능 비교 결과',
  'optimization.executionTime.cachePerformance': '캐시 성능 향상',
  
  // OptimizationDemos component
  'optimization.workingPrinciple': '동작 원리',
  'optimization.workingPrinciple.before': '최적화 전:',
  'optimization.workingPrinciple.after': '최적화 후 (React.memo):',
  'optimization.workingPrinciple.afterBullet1': 'Props 변경시만 자식 리렌더링',
  'optimization.workingPrinciple.afterBullet2': '이전 결과를 재사용',
  'optimization.workingPrinciple.afterBullet3': '성능 크게 향상',
  'optimization.workingPrinciple.afterUseMemo': '최적화 후 (useMemo):',
  'optimization.workingPrinciple.reRenderEveryTime': '부모가 바뀔 때마다 자식도 다시 그림',
  'optimization.workingPrinciple.noMatterPropsChange': 'Props 변경 여부와 관계없음',
  'optimization.workingPrinciple.unnecessaryReRender': '불필요한 렌더링으로 성능 저하',
  'optimization.workingPrinciple.onlyWhenPropsChange': 'Props 변경시만 자식 리렌더링',
  'optimization.workingPrinciple.reusePreviousResult': '이전 결과를 재사용',
  'optimization.workingPrinciple.efficientPerformance': '효율적인 성능',
  'optimization.workingPrinciple.recalculateEveryTime': '매번 계산을 처음부터 실행',
  'optimization.workingPrinciple.duplicateCalculation': '동일한 입력에 대해 중복 계산',
  'optimization.workingPrinciple.wasteResources': '사용자 경험 저하',
  'optimization.workingPrinciple.firstCalculationOnly': '첫 번째만 계산, 이후는 캐시 사용',
  'optimization.workingPrinciple.recalculateWhenDepsChange': '의존성이 변경될 때만 재계산',
  'optimization.workingPrinciple.saveCalculationTime': '즉시 응답으로 UX 향상',
  
  // Render Count 최적화 내용
  'optimization.renderCount.principle.memo': 'React.memo의 핵심: ',
  'optimization.renderCount.principle.memoDesc': '부모 컴포넌트가 리렌더링되어도 자식은 props가 변경되지 않으면 리렌더링되지 않습니다.',
  'optimization.renderCount.principle.experience': '아래에서 직접 체험해보세요!',
  
  // Render Count Demo
  'optimization.renderCount.beforeOptimization': '최적화 전',
  'optimization.renderCount.afterOptimization': '최적화 후 (React.memo)',
  'optimization.renderCount.everyTimeRerendering': '매번 re-rendering 발생',
  'optimization.renderCount.onlyPropsChangeRerendering': 'Props 변경시만 re-rendering',
  'optimization.renderCount.parentInefficient': '부모가 바뀔 때마다 자식도 다시 그려짐 (비효율적)',
  'optimization.renderCount.propsReuseEfficient': 'Props가 같으면 재사용 (효율적) - React 19에서는 자동!',
  
  // Execution Time Demo
  'optimization.executionTime.beforeOptimization': '최적화 전',
  'optimization.executionTime.afterOptimization': '최적화 후 (useMemo)',
  'optimization.executionTime.primeSlow': '큰 소수 판별을 매번 다시 계산 (느림)',
  'optimization.executionTime.cacheUseFast': '한 번 계산하고 캐시 사용 (빠름)',
  'optimization.executionTime.cacheUse': '캐시 사용',
  
  // UI Responsiveness Demo
  'optimization.uiResponsiveness.beforeOptimization': '최적화 전',
  'optimization.uiResponsiveness.afterOptimization': '최적화 후',
  'optimization.uiResponsiveness.typingTest': '타이핑 테스트',
  'optimization.uiResponsiveness.heavyCalculation': '무거운 계산',
  'optimization.uiResponsiveness.runHeavyCalculation': '무거운 계산 실행',
  'optimization.uiResponsiveness.changeTheme': '테마 변경',
  'optimization.uiResponsiveness.charactersTyped': '입력된 글자 수',
  'optimization.uiResponsiveness.msDelay': 'ms 지연',
  'optimization.uiResponsiveness.inputPlaceholder': '타이핑해보세요...',
  
  // Memory Management Demo
  'optimization.memoryManagement.useMemoCore': 'useEffect cleanup의 핵심: ',
  'optimization.memoryManagement.useMemoDesc': 'useEffect cleanup으로 memory leak을 방지합니다. 사용하지 않는 것을 계속 메모리에 두면 앱이 느려집니다.',
  'optimization.memoryManagement.createListener': '리스너 생성',
  'optimization.memoryManagement.removeListener': '리스너 제거',
  'optimization.memoryManagement.listenerCount': '개',
  'optimization.memoryManagement.memoryLeakWarning': '제거해도 메모리에 남아있음 (Memory Leak!)',
  'optimization.memoryManagement.properCleanup': 'cleanup으로 완전히 제거됨 (효율적)',
  'optimization.memoryManagement.accumulatedListeners': '누적된 리스너',
  'optimization.memoryManagement.currentListeners': '현재 리스너',
  'optimization.memoryManagement.keepStacking': '메모리에 계속 쌌임',
  'optimization.memoryManagement.actuallyInUse': '실제 사용 중인 것만',
  'optimization.memoryManagement.memoryLeakOccured': '개의 메모리 누수 발생!',
  
  // 동작 원리 추가
  'optimization.workingPrinciple.listenerKeepStacking': '이벤트 리스너가 계속 쌌임',
  'optimization.workingPrinciple.notRemovedFromMemory': '메모리에서 제거되지 않음',
  'optimization.workingPrinciple.memoryLeakOccur': 'Memory Leak 발생!',
  'optimization.workingPrinciple.oneListener': '하나의 리스너만 유지',
  'optimization.workingPrinciple.prevListenerRemove': '이전 리스너는 제거',
  'optimization.workingPrinciple.efficientMemory': '효율적인 메모리 관리',
  
  // useMemo 데모 코드 주석
  'optimization.code.comment.memoExample': 'Deps가 바뀔 때만 계산해요',
  'optimization.code.comment.expensiveCalculation': '무거운 계산 함수 (성능 테스트용)',
  
  // React.memo 데모
  'optimization.reactMemo.core': 'React.memo의 핵심: ',
  'optimization.reactMemo.coreDesc': 'Count 버튼을 클릭하면 부모 컴포넌트만 리렌더링되고, Expensive 버튼을 클릭하면 부모와 자식 컴포넌트 모두 리렌더링됩니다. React.memo는 props가 변경되지 않으면 이전 렌더링 결과를 재사용하여 성능을 향상시킵니다.',
  'optimization.reactMemo.countButton': 'Count 버튼',
  'optimization.reactMemo.expensiveButton': 'Expensive 버튼',
  'optimization.reactMemo.countButtonEffect': '📊 Count 버튼 효과',
  'optimization.reactMemo.expensiveButtonEffect': '📊 Expensive 버튼 효과',
  'optimization.reactMemo.countClicked': '회 클릭됨',
  'optimization.reactMemo.propsChanged': 'Props 변경됨!',
  'optimization.reactMemo.interactive': '인터랙티브 테스트',
  'optimization.reactMemo.clickCountMultiple': 'Count 버튼을 여러 번 클릭해보세요',
  'optimization.reactMemo.checkRenderCount': 'Render Count가 변하지 않는 것을 확인하세요',
  'optimization.reactMemo.clickExpensive': 'Expensive 버튼을 클릭해보세요',
  'optimization.reactMemo.checkRenderIncrease': 'Render Count가 증가하는 것을 확인하세요',
  'optimization.reactMemo.howItWorks': '어떻게 동작할까요?',
  'optimization.reactMemo.magic': 'React.memo의 마법: ',
  'optimization.reactMemo.useMemoExecutionCount': 'useMemo가 실행된 횟수',
  'optimization.reactMemo.parentOnlyRerendered': '부모만 리렌더링됨',
  'optimization.reactMemo.notClickedYet': '아직 클릭 안함',
  'optimization.reactMemo.countChangedExpensiveValueSame': 'Count가 바뀌어도 expensiveValue는 그대로',
  'optimization.reactMemo.parentChildBothRerendered': '부모+자식 모두 리렌더링',
  'optimization.reactMemo.expensiveValueChangedUseMemoRerun': 'expensiveValue가 바뀌면 useMemo도 재실행',
  'optimization.reactMemo.preventRenders': '번의 불필요한 렌더링을 방지합니다.',
  'optimization.reactMemo.parent': '부모 컴포넌트 렌더링',
  'optimization.reactMemo.child': '자식 컴포넌트 렌더링',
  'optimization.reactMemo.withoutMemo': 'Without React.memo',
  'optimization.reactMemo.withMemo': 'With React.memo',
  'optimization.reactMemo.alwaysRender': '항상 리렌더링',
  'optimization.reactMemo.onlyPropsChange': 'Props 변경 시만',
  'optimization.reactMemo.executeCount': '실행 횟수',
  'optimization.reactMemo.renderCountMemo': 'useMemo가 실행된 횟수',
  
  // useMemo 가이드
  'optimization.useMemoGuide.calculatePrimeNumber': '소수 계산',
  'optimization.useMemoGuide.enterNumber': '숫자',
  'optimization.useMemoGuide.isPrime': '소수입니다',
  'optimization.useMemoGuide.notPrime': '소수가 아닙니다',
  'optimization.useMemoGuide.prime': '판별:',
  'optimization.useMemoGuide.heavyCalculationRunning': '무거운 계산 실행 중...',
  
  // Execution Time 최적화 내용
  'optimization.executionTime.useMemoCore': 'useMemo의 핵심: ',
  'optimization.executionTime.useMemoDesc': '복잡한 계산을 매번 반복하면 앱이 느려집니다. 한 번 계산한 결과를 저장해두고 재사용하면 훨씬 빠릅니다.',
  'optimization.executionTime.cachedResult': '캐시된 결과',
  'optimization.executionTime.calculationTimeLabel': '계산 시간',
  'optimization.executionTime.performanceImprovement': '🎉 {percent}% 성능 향상!',
  
  // Memory Management 최적화 내용
  'optimization.memoryManagement.beforeOptimization': '최적화 전',
  'optimization.memoryManagement.afterOptimization': '최적화 후',
  'optimization.memoryManagement.listenerAddedNotRemoved': '리스너 추가 (제거 안함)',
  'optimization.memoryManagement.listenerManagedWithCleanup': '리스너 관리 (Cleanup)',
  'optimization.memoryManagement.noCleanupWarning': '⚠️ No Cleanup: {count}개의 메모리 누수 발생!',
  'optimization.memoryManagement.noCleanup': 'No Cleanup',
  'optimization.memoryManagement.withCleanup': 'With Cleanup',
  'optimization.memoryManagement.cleanupOnUnmount': '컴포넌트 제거시 정리됨',
  'optimization.memoryManagement.cleanResourceCleanup': '깔끕한 리소스 정리',
  'optimization.memoryManagement.add': '추가',
  'optimization.memoryManagement.remove': '제거',
  'optimization.memoryManagement.activeListeners': 'Active Listeners',
  'optimization.memoryManagement.memoryStatusMonitoring': '메모리 상태 모니터링',
  
  // UI Responsiveness 최적화 내용
  'optimization.uiResponsiveness.core': 'UI 반응성의 핵심: ',
  'optimization.uiResponsiveness.coreDesc': '타이핑할 때 글자가 늦게 나타나면 답답합니다. 불필요한 작업을 줄이면 사용자 입력에 즉시 반응할 수 있습니다.',
  'optimization.uiResponsiveness.slowRerender': '타이핑할 때마다 리렌더링',
  'optimization.uiResponsiveness.optimized': '입력에만 집중',
  'optimization.uiResponsiveness.heavyCalcEachTime': '매번 무거운 작업 실행',
  'optimization.uiResponsiveness.separateHeavyWork': '무거운 작업 분리',
  'optimization.uiResponsiveness.slowTyping': '타이핑이 느림',
  'optimization.uiResponsiveness.fastTyping': '즉시 반응',
  'optimization.uiResponsiveness.drawDotsEveryType': '타이핑할 때마다 100개 점을 다시 그림',
  'optimization.uiResponsiveness.unnecessaryDOMManipulation': '불필요한 DOM 조작',
  'optimization.uiResponsiveness.laggyInputExperience': '버벅거리는 입력 경험',
  'optimization.uiResponsiveness.dotsNotRedrawn': '점들은 변경 없어서 다시 그리지 않음',
  'optimization.uiResponsiveness.onlyNecessaryUpdates': '필요한 부분만 업데이트',
  'optimization.uiResponsiveness.smoothTypingExperience': '부드러운 타이핑 경험',
  'optimization.renderCount.whenParentChanges': '부모가 바뀌 때마다 자식도 다시 그림',
  'optimization.renderCount.regardlessOfProps': 'Props 변경 여부와 관계없음',
  'optimization.renderCount.performanceDegradation': '불필요한 렌더링으로 성능 저하',
  'optimization.realtimeFeedback': '실시간 피드백',
  'optimization.reactMemoDemoTitle': 'React.memo 실시간 데모',
  'optimization.reactMemo.coreExplanation': '부모 컴포넌트가 리렌더링되어도 자식은 props가 변경되지 않으면 리렌더링되지 않습니다.',
  'optimization.reactMemo.tryItBelow': '아래에서 직접 체험해보세요!',
  'optimization.reactMemo.detailedExplanation': '<span>Count 버튼</span>을 클릭하면 부모 컴포넌트만 리렌더링되고, <span>Expensive 버튼</span>을 클릭하면 부모와 자식 컴포넌트 모두 리렌더링됩니다. React.memo는 props가 변경되지 않으면 이전 렌더링 결과를 재사용하여 불필요한 계산을 방지합니다. 마치 캐시처럼 작동하여 성능을 크게 향상시킵니다.',
  'optimization.reactMemo.countButtonTitle': 'Count 버튼:',
  'optimization.reactMemo.countButtonBullet1': '부모 컴포넌트만 리렌더링',
  'optimization.reactMemo.countButtonBullet2': '자식 컴포넌트는 props 변경 없음',
  'optimization.reactMemo.countButtonBullet3': 'React.memo로 인해 리렌더링 방지',
  'optimization.reactMemo.expensiveButtonTitle': 'Expensive 버튼:',
  'optimization.reactMemo.expensiveButtonBullet1': '부모 컴포넌트 리렌더링',
  'optimization.reactMemo.expensiveButtonBullet2': 'expensiveValue props 변경됨',
  'optimization.reactMemo.expensiveButtonBullet3': '자식 컴포넌트도 리렌더링',
  
  'optimization.uiResponsiveness.title': 'UI Responsiveness 최적화',
  'optimization.uiResponsiveness.description': '사용자 입력에 대한 즉각적인 반응을 보장합니다.',
  'optimization.uiResponsiveness.memo.desc': '무거운 연산과 UI 업데이트를 분리하여 반응성을 유지합니다.',
  'optimization.uiResponsiveness.nonOptimized.desc': '점들이 계속 깜빡임',
  'optimization.uiResponsiveness.optimized.desc': '점들이 고정됨',
  'optimization.uiResponsiveness.noInput': '아직 입력 안함',
  
  'optimization.memoryManagement.title': 'Memory Management 최적화',
  'optimization.memoryManagement.description': '메모리 누수를 방지하고 효율적으로 관리합니다.',
  'optimization.memoryManagement.memo.desc': '이벤트 리스너와 타이머를 적절히 정리하여 메모리 누수를 방지합니다.',
  'optimization.memoryManagement.nonOptimized.desc': '메모리에 계속 쌓임',
  'optimization.memoryManagement.optimized.desc': '실제 사용 중인 것만',
  'optimization.memoryManagement.none': '아직 없음',
  
  'optimization.reactMemo.title': 'React.memo 실시간 데모',
  'optimization.reactMemo.description': 'props가 변경되지 않은 컴포넌트의 리렌더링을 방지합니다.',
  'optimization.reactMemo.nonOptimized.desc': '부모만 리렌더링됨',
  'optimization.reactMemo.optimized.desc': '부모+자식 모두 리렌더링',
  'optimization.reactMemo.notClicked': '아직 클릭 안함',
  
  'optimization.useMemoGuide.title': 'useMemo 최적화 가이드',
  'optimization.useMemoGuide.description': '의존성이 변경되지 않으면 계산을 다시 하지 않습니다.',
  
  'optimization.renderingGuide.title': '렌더링 최적화 가이드',
  
  // Form Actions
  'form.actionDescription': '<strong>useActionState</strong>와 <strong>Form Actions</strong>로 폼 처리가 훨씬 간단해졌습니다. 자동 폼 리셋, 에러 처리, pending 상태를 자동으로 관리합니다.',
  
  // Touch Demo
  'touch.noGesture': '아직 제스처가 없습니다',
  'touch.swipeHint': '스와이프 해보세요',
  'touch.rightSwipe': '오른쪽 스와이프',
  'touch.leftSwipe': '왼쪽 스와이프',
  'touch.downSwipe': '아래 스와이프',
  'touch.upSwipe': '위 스와이프',
  'touch.tap': '탭!',
  'touch.swipeRightTo': '오른쪽으로 스와이프',
  'touch.swipeLeftTo': '왼쪽으로 스와이프',
  'touch.swipeDownTo': '아래로 스와이프',
  'touch.swipeUpTo': '위로 스와이프',
  'touch.click': '클릭!',
  'touch.scrollHint': '좌우 스크롤',
  'touch.useTip.title': '사용 팁',
  'touch.useTip.gesture': '터치 제스처로 다양한 인터랙션을 체험해보세요',
  'touch.useTip.tab': '탭 버튼을 눌러 다른 Hook을 확인하세요',
  'touch.useTip.pinch': '핀치 제스처로 확대/축소를 해보세요',
  'touch.useTip.drag': '드래그로 요소를 움직여보세요',
  'touch.touch': '터치',
  'touch.touchGestureHint': '화면을 클릭하거나 터치하고 제스처를 해보세요',
  'touch.swipeOrDragHint': '좌우 또는 상하로 드래그하거나 스와이프해보세요',
  'touch.pinch': '핀치!',
  'touch.scale': '확대',
  'touch.pinchHint': '두 손가락으로 핀치해보세요 (터치 전용)',
  'touch.drag': '드래그',
  'touch.dragHint': '원을 드래그해서 움직여보세요',
  'touch.touchMouseSupport': '터치 · 마우스 지원',
  
  // Mobile Demo
  'mobile.typingPlaceholder': '타이핑해보세요...',
  'mobile.inputLabel': '입력된 값:',
  'mobile.noInput': '입력 없음',
  'mobile.newItemPlaceholder': '새 항목...',
  'mobile.menuOpen': '메뉴 열기',
  'mobile.count': '카운트',
  'mobile.timer': '타이머',
  'mobile.text': '텍스트',
  
  // Mobile Navigation
  'navigation.menuOpen': '메뉴 열기',
  'navigation.tapToMove': '탭하여 섹션을 이동하세요',
  
  // Demo Components
  'demo.useCallback.description': '함수를 메모이제이션하여 성능을 최적화합니다',
  'demo.useCallback.tip': 'useCallback으로 함수가 메모이제이션되어 불필요한 리렌더링을 방지합니다!',
  'demo.useRef.description': 'DOM 요소에 접근하거나 렌더링 간에 값을 유지합니다',
  'demo.useRef.tip': 'Ref 값이 변경되어도 화면이 업데이트되지 않습니다!',
  'demo.useMemo.description': '비용이 높은 계산을 메모이제이션하여 성능을 최적화합니다',
  'demo.useMemo.tip': 'useMemo로 필터링 계산을 최적화하여 성능을 향상시킵니다!',
  'demo.useMemo.noItems': '아이템이 없습니다. \'Add Item\'을 눌러 추가하세요!',
  'demo.useMemo.noFilteredItems': '필터 조건에 맞는 아이템이 없습니다.',
  'demo.useEffect.description': '부수 효과를 처리하고 cleanup을 수행합니다',
  'demo.useEffect.tip': 'useEffect cleanup으로 타이머가 정리되어 메모리 누수를 방지합니다!',
  
  // Mobile Hooks Guide
  'mobile.useState.description': '상태를 관리하는 가장 기본적인 Hook',
  'mobile.useEffect.description': '컴포넌트의 생명주기를 관리하는 Hook',
  'mobile.useRef.description': 'DOM 요소에 직접 접근하거나 값을 저장하는 Hook',
  'mobile.useMemo.description': '계산 결과를 메모이제이션하여 성능을 최적화하는 Hook',
  'mobile.useCallback.description': '함수를 메모이제이션하여 성능을 최적화하는 Hook',
  'mobile.touchDemo': '터치 데모',
  'mobile.touchDemo.description': '터치 제스처로 직접 체험해보세요!',
  'mobile.basicDemo': '기본 데모',
  'mobile.basicDemo.description': '기본 기능을 체험해보세요!',
  
  // Mobile Main Content
  'mobile.whatIsHook': 'Hook이란?',
  'mobile.whatIsHook.desc': '함수형 컴포넌트에서 React의 상태와 생명주기 기능을 사용할 수 있게 해주는 함수입니다.',
  'mobile.whyUseHooks': '왜 Hook을 사용할까?',
  'mobile.whyUseHooks.desc': '컴포넌트 간에 상태 로직을 재사용하기 쉽고, 복잡한 컴포넌트를 더 쉽게 이해할 수 있습니다.',
  'mobile.hookAdvantages': 'Hook의 장점',
  'mobile.hookAdvantages.desc': '클래스 컴포넌트의 this 바인딩 문제가 없고, 컴포넌트를 더 작은 함수로 나누어 테스트하기 쉽습니다.',
  
  // React Hooks Guide Additional
  'guide.whenToUse': '언제 사용할까?',
  'guide.whenToUse.desc': '함수형 컴포넌트에서 상태 관리, 사이드 이펙트 처리, 또는 다른 React 기능을 사용할 때 필요합니다.',
  'guide.whenToUse.desc2': '함수형 컴포넌트에서 상태 관리, 사이드 이펙트 처리, 컴포넌트 간 로직 공유가 필요할 때 사용합니다.',
  'guide.coreHooks.title': '핵심 Hooks 완벽 가이드',
  'guide.coreHooks.description': 'React의 기본 Hooks들을 실시간 데모와 함께 학습하세요. 각 Hook의 동작 원리와 실제 사용법을 체험할 수 있습니다.',
  'guide.rules.title': 'Hooks 사용 규칙',
  'guide.optimization.title': '성능 최적화 마스터하기',
  'guide.optimization.description': 'React.memo, useMemo, useCallback 등을 활용한 성능 최적화 기법을 실시간 데모와 함께 학습하세요.',
  'guide.advanced.title': '고급 패턴 실험실',
  'guide.advanced.description': 'useCallback, useRef, useEffect 등 고급 Hook 패턴들을 실시간으로 실험해보세요. 각 패턴의 동작 원리와 최적화 효과를 직접 확인할 수 있습니다.',
  'guide.footer.madeWith': '로 만들어졌습니다',
  'guide.footer.forDevelopers': 'React 개발자들을 위해',
  'guide.footer.description': 'React Hooks의 모든 것을 배우고, React 19의 혁신적인 기능들을 체험해보세요. 실시간 데모와 함께하는 인터랙티브 학습 가이드입니다.',
  'guide.rules.dontTitle': '절대 하지 말아야 할 것',
  'guide.rules.dont.conditional': '조건문, 반복문, 중첩 함수 안에서 Hook 호출',
  'guide.rules.dont.regular': '일반 JavaScript 함수에서 Hook 호출',
  'guide.rules.dont.class': '클래스 컴포넌트에서 Hook 사용',
  'guide.rules.doTitle': '올바른 사용법',
  'guide.rules.do.topLevel': 'React 함수형 컴포넌트 최상위에서만 호출',
  'guide.rules.do.customHook': '커스텀 Hook 최상위에서만 호출',
  'guide.rules.do.sameOrder': 'Hook 호출 순서는 항상 동일하게 유지',
  'guide.rules.whyTitle': '왜 이런 규칙이 필요한가요?',
  'guide.rules.whyDesc': 'React는 Hook의 호출 순서에 의존하여 상태를 올바르게 연결합니다. 조건부 Hook 호출은 이 순서를 깨뜨리고 버그를 유발합니다.',
  
  // React 19 Features
  'react19.title': 'React 19',
  'react19.subtitle': '더 강력해진 최신 기능들',
  'react19.newWay': '🎉 React 19의 새로운 방식:',
  'react19.newFormHooks': '🎉 새로운 Form Hooks:',
  'react19.noLongerNeeded': '🎉 더 이상 필요없어진 코드:',
  'react19.newResourceAPIs': '🎉 새로운 Resource APIs:',
  'react19.newFeatures.title': 'React 19의 혁신적인 새로운 Hook들',
  'react19.newFeatures.description': 'React 19에서는 개발자 경험을 크게 향상시키는 새로운 Hook들과 기능들이 추가되었습니다. 특히 Actions, Form Actions, use() Hook 등이 핵심입니다.',
  'react19.actionsAndUseTransition': 'Actions · useTransition',
  'react19.actionsAndUseTransition.subtitle': '비동기 상태 관리의 혁신',
  'react19.actions.title': 'Actions · useTransition',
  'react19.actions.subtitle': '비동기 상태 관리의 혁신',
  'react19.actions.description': 'React 19의 <strong>Actions</strong>는 async 함수를 transitions에서 사용할 수 있게 해줍니다.',
  'react19.actions.desc': '사용자 경험을 해치지 않고 비동기 상태 업데이트를 처리합니다. 폼 제출, 데이터 저장, 페이지 전환 등의 비동기 작업을 우아하게 처리할 수 있습니다.',
  'react19.actions.autoManagement': 'pending 상태, 에러 처리, 낙관적 업데이트를 자동으로 관리합니다.',
  'react19.formActions.simplifiedDesc': '폼 처리가 훨씬 간단해졌습니다. 자동 폼 리셋, 에러 처리, pending 상태를 자동으로 관리합니다.',
  'react19.formActions.withUseActionState': '<strong>useActionState</strong>와 <strong>Form Actions</strong>로',
  'react19.actions.benefit': '🎉 React 19의 새로운 방식:',
  'react19.formActionsAndUseActionState': 'Form Actions · useActionState',
  'react19.formActionsAndUseActionState.subtitle': '폼 처리가 놀락도록 간단해짐',
  'react19.formActions.title': 'Form Actions · useActionState',
  'react19.formActions.subtitle': '폼 처리가 놀랍도록 간단해짐',
  'react19.useHook': 'use() Hook',
  'react19.useHook.subtitle': 'Promise와 Context를 더 쉽게',
  'react19.use.title': 'use() Hook',
  'react19.use.subtitle': 'Promise와 Context를 더 쉽게',
  'react19.use.description': '새로운 <strong>use() Hook</strong>으로 Promise를 직접 읽을 수 있습니다. 조건문 안에서도 사용 가능한 유일한 Hook입니다.',
  'react19.use.desc': '조건부로 Promise를 읽고, Context를 조건부로 사용할 수 있습니다. Suspense와 함께 사용하여 비동기 데이터를 선언적으로 사용할 수 있습니다.',
  'react19.useFormStatusAndUseOptimistic': 'useFormStatus · useOptimistic',
  'react19.useFormStatusAndUseOptimistic.subtitle': '폼 상태 관리의 새로운 패러다임',
  'react19.formHooks.title': 'useFormStatus · useOptimistic',
  'react19.formHooks.subtitle': '폼 상태 관리의 새로운 패러다임',
  'react19.formHooks.description': '<strong>useFormStatus</strong>로 폼의 pending 상태를 쉽게 관리하고, <strong>useOptimistic</strong>으로 즉시 UI 업데이트를 구현할 수 있습니다.',
  'react19.formHooks.desc': '폼의 pending 상태를 추적하고 낙관적 업데이트를 수행합니다. 서버 응답을 기다리는 동안 UI를 즉시 업데이트할 수 있습니다.',
  'react19.formHooks.benefit': '🎉 새로운 Form Hooks:',
  'react19.serverComponentsAndReactCompiler': 'Server Components · React Compiler',
  'react19.serverComponentsAndReactCompiler.subtitle': '자동 최적화의 마법',
  'react19.compiler.title': 'Server Components · React Compiler',
  'react19.compiler.subtitle': '자동 최적화의 마법',
  'react19.compiler.description': 'React 19의 새로운 컴파일러는 <strong>useMemo</strong>, <strong>useCallback</strong>, <strong>React.memo</strong>를 자동으로 적용합니다. 개발자가 수동으로 최적화하지 않아도 React가 알아서 처리합니다.',
  'react19.compiler.desc': 'React Compiler가 코드를 분석하고 자동으로 최적화합니다. useMemo, useCallback, React.memo를 수동으로 추가할 필요가 없어집니다.',
  'react19.compiler.benefit': '🎉 더 이상 필요없어진 코드:',
  'react19.resourcePreloadingAPIs': 'Resource Preloading APIs',
  'react19.resourcePreloadingAPIs.subtitle': '성능 최적화의 새로운 차원',
  'react19.resources.title': 'Resource Preloading APIs',
  'react19.resources.subtitle': '성능 최적화의 새로운 차원',
  'react19.resources.description': '<strong>prefetchDNS</strong>, <strong>preconnect</strong>, <strong>preload</strong>, <strong>preinit</strong> 등 새로운 리소스 프리로딩 API들로 페이지 성능을 크게 향상시킬 수 있습니다.',
  'react19.resources.desc': '리소스를 사전에 로드하여 성능을 향상시킵니다. 다양한 레벨의 프리로딩을 통해 사용자 경험을 개선할 수 있습니다.',
  'react19.resources.benefit': '🎉 새로운 Resource APIs:',
  'react19.upgrade.guideTitle': 'React 19 업그레이드 가이드',
  'react19.upgrade.tip': 'React 19는 이전 버전과의 호환성을 유지하면서 점진적으로 새로운 기능을 도입할 수 있습니다.',
  'react19.upgrade.title': 'React 19 업그레이드 가이드',
  'react19.upgrade.step1': '1단계:',
  'react19.upgrade.step1.desc': 'React 19.1.0으로 업그레이드',
  'react19.upgrade.step2': '2단계:',
  'react19.upgrade.step2.desc': '새로운 Actions 패턴 적용',
  'react19.upgrade.step3': '3단계:',
  'react19.upgrade.step3.desc': 'Form Actions로 폼 처리 현대화',
  'react19.upgrade.step4': '4단계:',
  'react19.upgrade.step4.desc': 'React Compiler의 자동 최적화 활용',
  'react19.upgrade.step5': '5단계:',
  'react19.upgrade.step5.desc': 'Resource Preloading APIs로 성능 향상',
  
  // Code Examples in React 19
  'react19.code.beforeReact19': '// Before React 19',
  'react19.code.withReact19': '// React 19',
  'react19.code.comment.autoMemo': '자동으로 useMemo 적용',
  'react19.code.comment.autoCallback': '자동으로 useCallback 적용',
  'react19.code.comment.autoMemoComponent': '자동으로 React.memo 적용',
  'react19.code.comment.formStatus': 'useFormStatus로 폼 상태 관리',
  'react19.code.comment.optimistic': 'useOptimistic으로 낙관적 업데이트',
  'react19.code.comment.preinit': '즉시 로드 및 실행',
  'react19.code.comment.preload': '폰트 프리로드',
  'react19.code.comment.prefetch': 'DNS 프리페치',
  'react19.code.comment.preconnect': '연결 프리페치',
  'react19.code.comment.conditionPromise': 'Promise를 직접 사용',
  'react19.code.comment.conditionUse': '조건부 사용 가능!',
  'react19.code.comment.safePredict': 'React 19에서는 더 안전하고 예측 가능한 방식으로 작동',
  
  // Demo Components Common
  'demo.feedback': '실시간 피드백',
  'demo.count': '카운트',
  'demo.timer': '타이머',
  'demo.seconds': '초',
  'demo.milliseconds': '밀리초',
  'demo.increment': '증가',
  'demo.decrement': '감소',
  'demo.addItem': '항목 추가',
  'demo.removeItem': '제거',
  'demo.filterPlaceholder': '항목 필터링...',
  'demo.allItems': '전체 아이템',
  'demo.filteredItems': '필터링된 아이템',
  'demo.incrementCount': '카운트 증가',
  'demo.startTimer': '타이머 시작',
  'demo.stopTimer': '타이머 정지',
  'demo.resetTimer': '타이머 리셋',
  'demo.focusInput': '입력란 포커스',
  'demo.incrementRef': 'Ref 증가',
  'demo.showRefValue': 'Ref 값 표시',
  'demo.focusMePlaceholder': '포커스하세요!',
  'demo.refCountDisplay': 'Ref Count: {count} (화면에 표시된 값)',
  'demo.refValueAlert': 'Ref 값: {value}',
  'demo.decrease': '감소',
  'demo.increase': '증가',
  'demo.add': '추가',
  'demo.delete': '삭제',
  'demo.noItems': '아직 항목이 없습니다',
  'demo.newItem': '새 항목...',
  'demo.reset': '초기화',
  
  // Optimization Demos Specific
  'optimization.demoBox.keyMetrics': '주요 성능 메트릭',
  'optimization.demoBox.renderCountOptimization': 'Render Count 최적화',
  'optimization.demoBox.executionTimeOptimization': 'Execution Time 최적화',
  'optimization.demoBox.uiResponsivenessOptimization': 'UI Responsiveness 최적화',
  'optimization.demoBox.memoryManagementOptimization': 'Memory Management 최적화',
  'optimization.metrics.renderCount': '화면을 다시 그리는 횟수',
  'optimization.metrics.renderCount.title': 'Render Count',
  'optimization.metrics.executionTime.title': 'Execution Time',
  'optimization.metrics.uiResponsiveness.title': 'UI Responsiveness',
  'optimization.metrics.memoryManagement.title': 'Memory Management',
  'optimization.metrics.renderCount.desc': '적을수록 좋습니다. 마치 그림을 그릴 때 전체를 지우고 다시 그리는 것보다 필요한 부분만 수정하는 것이 효율적입니다.',
  'optimization.metrics.executionTime': '계산에 걸리는 시간',
  'optimization.metrics.executionTime.desc': '복잡한 계산 결과를 저장해두면 매번 다시 계산하지 않아도 됩니다. 계산기 결과를 메모해두는 것과 같습니다.',
  'optimization.metrics.uiResponsiveness': '사용자 입력 반응성',
  'optimization.metrics.uiResponsiveness.desc': '타이핑할 때 글자가 바로 나타나야 사용하기 편합니다. 스마트폰이 터치에 바로 반응하는 것처럼 빨라야 합니다.',
  'optimization.metrics.memoryManagement': '메모리 사용량',
  'optimization.metrics.memoryManagement.desc': '사용하지 않는 것들을 제때 정리해야 합니다. 책상 정리를 하지 않으면 공간이 부족해지는 것과 같습니다.',
  'optimization.memoryManagement.explanation': '사용하지 않는 것은 정리해야 메모리가 부족하지 않습니다. 마치 집에 쓰레기를 계속 쌓아두면 공간이 부족해지는 것과 같습니다.',
  'optimization.uiResponsiveness.redrawEveryTyping': '타이핑할 때마다 100개 점을 다시 그림 (버벅거림)',
  'optimization.testGuide.title': '단계별 테스트 가이드',
  'optimization.testGuide.step1': 'Count 버튼을 여러 번 클릭해보세요',
  'optimization.testGuide.step2': 'Render Count가 변하지 않는 것을 확인하세요',
  'optimization.testGuide.step3': 'Expensive 버튼을 클릭해보세요',
  'optimization.testGuide.step4': 'Render Count가 증가하는 것을 확인하세요',
  'optimization.useMemo.guideTitle': 'useMemo 최적화 가이드',
  'optimization.useMemo.guideDescription': '의존성이 변경되지 않으면 계산을 다시 하지 않습니다. Expensive Value를 변경해보면 계산이 실행되는 것을 Console에서 확인할 수 있습니다.',
  'optimization.useMemo.consoleMessage': 'Console 메시지:',
  'optimization.useMemo.performanceTip': '💡 성능 팁:',
  'optimization.useMemo.performanceTipDesc': 'useMemo는 계산 결과를 "기억"합니다. expensiveValue가 변경되지 않으면 이전 계산 결과를 재사용하여 불필요한 연산을 방지합니다.',
  'optimization.renderingOptimizationGuide': '렌더링 최적화 가이드',
  'optimization.guide.goodExample': '✅ 좋은 예시',
  'optimization.guide.badExample': '❌ 나쁜 예시',
  'optimization.guide.useUniqueId': '고유 ID를 key로 사용:',
  'optimization.guide.useArrayIndex': '배열 인덱스를 key로 사용:',
  'optimization.guide.keyPointTitle': '핵심 포인트:',
  'optimization.guide.keyPointDesc': 'React에서 key는 컴포넌트의 "신분증" 역할을 합니다. 고유한 key를 사용하면 React가 어떤 항목이 변경되었는지 정확히 파악하여 불필요한 리렌더링을 방지할 수 있습니다.',
  'optimization.renderCount.nonOptimized': '최적화 전',
  'optimization.renderCount.optimized': '최적화 후',
  'optimization.renderCount.optimizedWithMemo': '최적화 후 (React.memo)',
  'optimization.renderCount.reRenderingEveryTime': '매번 re-rendering 발생',
  'optimization.renderCount.reRenderingOnlyPropsChange': 'Props 변경시만 re-rendering',
  'optimization.renderCount.parentReRender': 'Parent Re-render',
  'optimization.renderCount.renderCountLabel': 'Render Count',
  'optimization.renderCount.unnecessaryRendersPrevented': '🎉 {count}번의 불필요한 렌더링 방지!',
  'optimization.renderCount.inefficient': '부모가 바뀔 때마다 자식도 다시 그려짐 (비효율적)',
  'optimization.renderCount.efficient': 'Props가 같으면 재사용 (효율적) - React 19에서는 자동!',
  'optimization.renderCount.performanceComparison': '성능 비교 결과',
  'optimization.renderCount.renderingCount': '렌더링 횟수',
  'optimization.performanceComparisonResult': '성능 비교 결과',
  'optimization.renderCount.parentClick': '부모 클릭!',
  'optimization.renderCount.clicks': '회 클릭됨',
  'optimization.memoryManagement.createListeners': '리스너 생성',
  'optimization.memoryManagement.clearListeners': '리스너 정리',
  'optimization.memoryManagement.activeCount': '개 활성화',
  'optimization.memoryManagement.inMemory': '메모리 상태:',
  'optimization.useMemo.calculatePrime': '소수 계산',
  'optimization.useMemo.number': '숫자',
  'optimization.useMemo.isPrime': '소수입니다',
  'optimization.useMemo.notPrime': '소수가 아닙니다',
  'optimization.heavyCalculation.running': '무거운 계산 실행 중...',
  'optimization.typingTest': '타이핑 테스트',
  'optimization.calculateHeavy': '무거운 계산 실행',
  'optimization.changeTheme': '테마 변경',
  'optimization.virtualList.title': 'Virtual List 렌더링',
  'optimization.virtualList.description': '긴 리스트도 가상화로 빠르게',
  'optimization.virtualList.itemsTotal': '개 아이템 중',
  'optimization.virtualList.itemsRendered': '개만 렌더링됨',
  'optimization.lazyLoading.title': 'Lazy Loading 데모',
  'optimization.lazyLoading.description': '필요할 때만 로드하여 초기 로딩 최적화',
  'optimization.lazyLoading.loadedNow': '지금 로드됨!',
  'optimization.lazyLoading.notLoaded': '아직 로드 안됨',
  'optimization.lazyLoading.loadComponent': '컴포넌트 로드',
  'optimization.debounce.title': 'Debounce/Throttle',
  'optimization.debounce.description': '이벤트 최적화로 성능 향상',
  'optimization.debounce.instantUpdates': '즉시 업데이트:',
  'optimization.debounce.debounced': 'Debounced (500ms):',
  'optimization.debounce.throttled': 'Throttled (500ms):',
  'optimization.debounce.inputPlaceholder': '타이핑해보세요...',
  'optimization.stateManagement.title': '효율적인 상태 관리',
  'optimization.stateManagement.description': '상태 구조 최적화로 리렌더링 감소',
  'optimization.stateManagement.nonOptimizedRenders': '최적화 전 렌더:',
  'optimization.stateManagement.optimizedRenders': '최적화 후 렌더:',
  'optimization.stateManagement.updateCount': '카운트 업데이트',
  'optimization.stateManagement.updateSettings': '설정 업데이트',
  'optimization.stateManagement.renderCount': '렌더링:',
  'optimization.stateManagement.theme': '테마:',
  'optimization.code.comment.expensiveCalc': '비용이 높은 계산',
  'optimization.code.comment.everyRender': '매 렌더링마다 실행됨!',
  'optimization.code.comment.depsChanged': 'deps가 바뀔 때만 실행',
  'optimization.code.comment.functionRecreated': '매번 새로운 함수 생성',
  'optimization.code.comment.depsChangedFunc': 'deps가 바뀔 때만 재생성',
  'optimization.code.comment.memoryLeak': '메모리 누수!',
  'optimization.code.comment.properCleanup': '적절한 정리',
  'optimization.code.comment.createManyListeners': '계속 쌓임',
  'optimization.code.comment.createOnce': '한 번만 생성',
  'optimization.testIt': '테스트해보세요!',
  'optimization.testIt2': '테스트해보세요',
  'optimization.notInputYet': '아직 입력 안함',
  'optimization.dotsBlinking': '점들이 계속 깜빡임',
  'optimization.dotsFixed': '점들이 고정됨',
  'optimization.noInput': '입력 없음',
  'optimization.noneYet': '아직 없음',
  'optimization.memoryStacking': '메모리에 계속 쌓임',
  'optimization.onlyInUse': '실제 사용 중인 것만',
  'optimization.notClickedYet': '아직 클릭 안함',
  'optimization.parentOnlyRerendered': '부모만 리렌더링됨',
  'optimization.parentChildRerendered': '부모+자식 모두 리렌더링',
  'optimization.keyMetrics': '주요 성능 메트릭',
  'optimization.renderingGuide': '렌더링 최적화 가이드',
};
