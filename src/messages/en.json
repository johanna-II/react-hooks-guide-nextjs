{
  "hero": {
    "title": "HOOKS",
    "subtitle": "Meet the <span>Future</span> of React",
    "description": "Learn everything about React Hooks and experience the innovative features of React 19. An interactive learning guide with real-time demos.",
    "getStarted": "Get Started",
    "viewCode": "View Code"
  },
  "navigation": {
    "home": "Home",
    "hooks": "React Hooks",
    "optimization": "Optimization",
    "menuOpen": "Open navigation menu",
    "tapToMove": "Tap to navigate between sections"
  },
  "common": {
    "loading": "Loading...",
    "error": "An error occurred",
    "retry": "Try again",
    "close": "Close",
    "open": "Open",
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit": "Edit",
    "add": "Add",
    "search": "Search",
    "filter": "Filter",
    "sort": "Sort",
    "reset": "Reset",
    "submit": "Submit",
    "back": "Back",
    "next": "Next",
    "previous": "Previous",
    "confirm": "Confirm",
    "yes": "Yes",
    "no": "No"
  },
  "guide": {
    "completeGuide": "Complete Guide",
    "hooksRules": "üìã Rules of Hooks",
    "whyHooksNeeded": "üöÄ Why Hooks are Needed",
    "beginnerTitle": "üéØ Complete React Hooks Guide for Beginners",
    "whatIsHook": "What is a Hook?",
    "whatIsHookDesc": "Hooks are functions that let you use React state and lifecycle features in functional components. You can use all React features without class components.",
    "whyUseHooks": "Why Use Hooks?",
    "whyUseHooksDesc": "Hooks make it easy to reuse stateful logic between components and make complex components easier to understand.",
    "hookAdvantages": "Advantages of Hooks",
    "hookAdvantagesDesc": {
      "short": "Easier to test by splitting components into smaller functions.",
      "value": "No 'this' binding issues from class components, and easier to test by splitting components into smaller functions."
    },
    "rules": {
      "title": "Rules of Hooks",
      "dontTitle": "Things You Must Never Do",
      "dont": {
        "conditional": "Call Hooks inside conditionals, loops, or nested functions",
        "regular": "Call Hooks in regular JavaScript functions",
        "class": "Use Hooks in class components"
      },
      "doTitle": "Correct Usage",
      "do": {
        "topLevel": "Only call at the top level of React function components",
        "customHook": "Only call at the top level of custom Hooks",
        "sameOrder": "Always maintain the same order of Hook calls"
      },
      "whyTitle": "Why Are These Rules Necessary?",
      "whyDesc": "React relies on the order of Hook calls. If you call Hooks conditionally or in loops, React can't correctly associate each Hook call with its state."
    },
    "whenToUse": {
      "desc2": "Use Hooks when you need state management, lifecycle methods, or other React features in functional components.",
      "value": "When to Use Hooks"
    },
    "coreHooks": {
      "title": "Core Hooks",
      "description": "Essential Hooks that every React developer should know."
    },
    "optimization": {
      "title": "Optimization Techniques",
      "description": "Learn how to optimize your React applications for better performance."
    },
    "footer": {
      "description": "Build amazing React applications with confidence.",
      "madeWith": "Made with ‚ù§Ô∏è",
      "forDevelopers": "for developers worldwide"
    }
  },
  "hooks": {
    "useState": {
      "title": "useState",
      "description": "The most basic Hook for managing component state.",
      "descriptionDetail": "A Hook for adding state to components."
    },
    "useEffect": {
      "title": "useEffect",
      "description": "Perform side effects and manage lifecycle.",
      "descriptionDetail": "A Hook for handling lifecycle-related tasks in components."
    },
    "useCallback": {
      "title": "useCallback",
      "description": "Memoize functions to prevent unnecessary recreation.",
      "descriptionDetail": "Memoize functions to prevent unnecessary re-renders."
    },
    "useMemo": {
      "title": "useMemo",
      "description": "Memoize expensive calculations.",
      "descriptionDetail": "Optimize performance by memoizing calculation results."
    },
    "useRef": {
      "title": "useRef",
      "description": "Maintain references to DOM elements or values.",
      "descriptionDetail": "A Hook for directly accessing DOM elements or storing values."
    },
    "codeExample": "Code Example",
    "realTimeDemo": "Real-time Demo",
    "typeSomething": "Type something...",
    "effectRunCount": "Effect Run Count",
    "browserTabNotice": "Watch the browser tab title change!",
    "clickToFocus": "Click the button to focus...",
    "focusCount": "Focus Count",
    "renderCount": "Render Count",
    "optimizationTip": "Functions are memoized with useCallback to prevent unnecessary re-renders!",
    "valueA": "Value A",
    "valueB": "Value B",
    "calculationResult": "Calculation Result",
    "calculationCount": "Calculation Count",
    "memoTip": "Calculations only run when A or B changes!"
  },
  "demo": {
    "title": "Demo",
    "description": "Check out working examples",
    "runDemo": "Run Demo",
    "viewCode": "View Code",
    "result": "Result",
    "timer": "Timer",
    "seconds": "seconds",
    "useState": {
      "title": "useState Demo",
      "description": "State management basics",
      "tip": "Click the button to increase the count"
    },
    "useEffect": {
      "title": "useEffect Demo",
      "description": "Lifecycle and side effects",
      "tip": "Effect runs every time you type"
    },
    "useCallback": {
      "title": "useCallback Demo",
      "description": "Function memoization",
      "tip": "Child component doesn't re-render if expensiveValue doesn't change",
      "triggerRerender": "Trigger Parent Re-render",
      "clickToSee": "Click to see how the buttons below react",
      "difference": "Difference",
      "whenClick": "When clicking the \"Trigger Parent Re-render\" button",
      "leftSide": "Left: Render count increases (new function every time)",
      "rightSide": "Right: Render count stays the same (function reused)"
    },
    "useMemo": {
      "title": "useMemo Demo",
      "description": "Value memoization",
      "tip": "Calculation only runs when value A or B changes",
      "noItems": "No items to display",
      "noFilteredItems": "No items match the filter"
    },
    "useRef": {
      "title": "useRef Demo",
      "description": "DOM references and value storage",
      "tip": "Ref stores values without causing renders"
    },
    "count": "Count",
    "increase": "Increase",
    "typed": "Typed",
    "increment": "Increment",
    "decrement": "Decrement",
    "feedback": "Feedback",
    "focusMePlaceholder": "Focus me!",
    "refCountDisplay": "Ref Count: {count}",
    "focusInput": "Focus Input",
    "incrementRef": "Increment Ref",
    "showRefValue": "Show Ref Value",
    "refValueAlert": "Current Ref Value: {value}",
    "reset": "Reset",
    "incrementCount": "Increment Count",
    "startTimer": "Start Timer",
    "stopTimer": "Stop Timer",
    "resetTimer": "Reset Timer",
    "allItems": "All Items",
    "filteredItems": "Filtered Items",
    "addItem": "Add Item",
    "filterPlaceholder": "Filter items...",
    "removeItem": "Remove",
    "newItem": "New item",
    "add": "Add",
    "noItems": "No items yet",
    "delete": "Delete",
    "decrease": "Decrease",
    "click": "Click Me"
  },
  "mobile": {
    "startButton": "Get Started",
    "swipeHint": "Or swipe left",
    "beginnerHooks": "React Hooks for Beginners",
    "meetFuture": "Meet the Future of React",
    "learnEverything": "Learn everything about React Hooks and experience the innovative features of React 19.",
    "text": "Text",
    "useState": {
      "description": "Manage component state with the useState Hook. State changes trigger re-renders."
    },
    "useEffect": {
      "description": "Handle side effects and lifecycle events. Run code after render or cleanup."
    },
    "useRef": {
      "description": "Access DOM elements directly and store values that persist across renders."
    },
    "useMemo": {
      "description": "Optimize performance by memoizing expensive calculations."
    },
    "useCallback": {
      "description": "Prevent unnecessary re-renders by memoizing callback functions."
    },
    "touchDemo": {
      "title": "Touch Interactive Demo",
      "description": "Try touch gestures like swipe, tap, and pinch to interact with the demo."
    },
    "basicDemo": {
      "title": "Basic Demo",
      "description": "See how this Hook works with a simple interactive example."
    },
    "whatIsHook": {
      "title": "What is a Hook?",
      "desc": "Hooks are special functions that let you 'hook into' React features like state and lifecycle in functional components."
    },
    "whyUseHooks": {
      "title": "Why Use Hooks?",
      "desc": "Hooks make your components cleaner, more reusable, and easier to test. They eliminate the complexity of class components."
    },
    "hookAdvantages": {
      "title": "Hook Advantages",
      "desc": "Write less code, share logic between components easily, and build more maintainable applications."
    },
    "typingPlaceholder": "Type something...",
    "inputLabel": "You typed:",
    "noInput": "Nothing typed yet"
  },
  "form": {
    "title": "Form Actions Demo",
    "description": "This demo simulates React 19's new Form Actions feature. Real Form Actions use useActionState and useFormStatus.",
    "formActions": {
      "code": "Form Actions Code",
      "example": "React 19 usage example."
    },
    "react19": {
      "benefits": "React 19 Benefits",
      "comparison": "Difference from Traditional Approach"
    },
    "benefits": {
      "autoReset": "Automatic form reset",
      "errorHandling": "Built-in error handling",
      "pendingState": "Automatic pending state management",
      "optimistic": "Optimistic update support"
    },
    "comparison": {
      "noUseState": "No need for useState + useEffect",
      "noManualError": "No manual error handling",
      "simpleState": "Simplified complex state management",
      "betterUX": "Better user experience"
    },
    "comment": {
      "actionStateUsage": "Please enter both name and email.",
      "submitFailure": "Submission failed. Please try again."
    },
    "submit": {
      "preparing": "Submitting...",
      "button": "Submit Form"
    },
    "submitAria": "Submit form",
    "name": "Name",
    "email": "Email",
    "message": "Message",
    "namePlaceholder": "Enter your name",
    "emailPlaceholder": "Enter your email",
    "messagePlaceholder": "Enter your message",
    "submitting": "Submitting...",
    "successMessage": "Form submitted successfully!",
    "errorMessage": "Please fill in all required fields.",
    "required": "Required",
    "actionDescription": "<strong>useActionState</strong> and <strong>Form Actions</strong> make form handling much simpler. They automatically manage form reset, error handling, and pending states."
  },
  "whyHooks": {
    "title": "Why Hooks are Needed",
    "wrapperHell": {
      "title": "Solving Wrapper Hell",
      "desc": "Simplify complex component trees caused by HOCs and Render Props.",
      "detail": "Unwrap deeply nested code like Russian dolls and organize it cleanly."
    },
    "lifecycleSimplification": {
      "title": "Lifecycle Simplification",
      "desc": "Consolidate logic scattered across multiple lifecycle methods into a single useEffect.",
      "detail": "Manage complex lifecycles like birth, growth, and destruction with a single function."
    },
    "thisRemoval": {
      "title": "Removing 'this'",
      "desc": "Write clean functional components without JavaScript's confusing 'this' binding.",
      "detail": "Write code clearly without confusion about who 'this' refers to."
    },
    "logicReuse": {
      "title": "Logic Reuse",
      "desc": "Easily reuse and share stateful logic with Custom Hooks.",
      "detail": "Assemble functionality like LEGO blocks and use them identically in other projects."
    },
    "typescriptFriendly": {
      "title": "TypeScript Friendly",
      "desc": "Write type-safe code using type inference and generics.",
      "detail": "Catch runtime errors at compile time to build more stable applications."
    },
    "performanceOptimization": {
      "title": "Performance Optimization",
      "desc": "Prevent unnecessary re-renders with React.memo, useMemo, and useCallback.",
      "detail": "Greatly improve user experience by reusing calculation results through memoization."
    },
    "items": {
      "stateful": {
        "title": "Reusable Stateful Logic",
        "desc": "Easily share stateful logic between components without HOCs or render props"
      },
      "simpleComponents": {
        "title": "Simpler Components",
        "desc": "Functional components are easier to understand and test than class components"
      },
      "bundleSize": {
        "title": "Better Bundle Size",
        "desc": "Functional components minify more efficiently than class components"
      },
      "noBinding": {
        "title": "No Binding Issues",
        "desc": "No need to worry about 'this' binding in event handlers"
      },
      "composition": {
        "title": "Better Composition",
        "desc": "Split components into smaller functions through Hooks"
      },
      "futureReady": {
        "title": "Future Ready",
        "desc": "React team focuses new features on functional components"
      }
    }
  },
  "optimization": {
    "metrics": {
      "title": "Key Performance Metrics",
      "description": "Essential metrics you need to understand for performance optimization.",
      "renderCount": {
        "title": "Render Count",
        "desc": "Track how many times components re-render"
      },
      "executionTime": {
        "title": "Execution Time",
        "desc": "Measure calculation and rendering performance"
      },
      "uiResponsiveness": {
        "title": "UI Responsiveness",
        "desc": "Ensure smooth user interactions"
      },
      "memoryManagement": {
        "title": "Memory Management",
        "desc": "Prevent memory leaks and optimize memory usage"
      },
      "renderCountTitle": "Render Count",
      "executionTimeTitle": "Execution Time",
      "uiResponsivenessTitle": "UI Responsiveness",
      "memoryManagementTitle": "Memory Management"
    },
    "renderCount": {
      "title": "Render Count Optimization",
      "description": "Improve performance by preventing unnecessary renders.",
      "memo": {
        "desc": "Components don't re-render if props haven't changed."
      },
      "improvement": "unnecessary renders prevented!",
      "test": "Test it out!",
      "beforeOptimization": "Before Optimization",
      "afterOptimization": "After Optimization (React.memo)",
      "parentInefficient": "Child re-renders whenever parent changes (inefficient)",
      "propsReuseEfficient": "Reuse when props are same (efficient) - Automatic in React 19!",
      "whenParentChanges": "Child re-renders whenever parent changes",
      "regardlessOfProps": "Regardless of prop changes",
      "performanceDegradation": "Performance degradation due to unnecessary renders",
      "everyTimeRerendering": "Re-rendering occurs every time",
      "parentReRender": "Parent Re-render",
      "renderCountLabel": "Render Count",
      "onlyPropsChangeRerendering": "Re-rendering only when props change",
      "renderingCount": "Rendering Count",
      "unnecessaryRendersPrevented": "{count} unnecessary renders prevented!"
    },
    "executionTime": {
      "title": "Execution Time Optimization",
      "description": "Memoize expensive calculations.",
      "memo": {
        "desc": "Don't recalculate if dependencies haven't changed."
      },
      "improvement": "% performance improvement!",
      "recalculationEveryTime": "Recalculation every time",
      "cachedResults": "Using cached results",
      "calculatePrime": "Calculate Prime",
      "calculateNow": "Calculate Now",
      "calculationTime": "milliseconds",
      "slowCalculation": "Recalculate large prime every time (slow)",
      "fastCalculation": "Calculate once and use cache (fast)",
      "performanceComparisonResult": "Performance Comparison Result",
      "cachePerformance": "Cache Performance Improvement",
      "beforeOptimization": "Before Optimization",
      "afterOptimization": "After Optimization (useMemo)",
      "primeSlow": "Recalculate large prime every time (slow)",
      "cacheUseFast": "Calculate once and use cache (fast)",
      "cacheUse": "Using Cache",
      "calculationTimeLabel": "Calculation Time",
      "performanceImprovement": "{percent}% performance improvement!",
      "useMemoCore": "The core of useMemo: ",
      "useMemoDesc": "Repeating complex calculations every time slows down your app. Storing and reusing calculated results is much faster.",
      "cachedResult": "Cached Result"
    },
    "workingPrinciple": {
      "before": "Before Optimization:",
      "after": "After Optimization (React.memo):",
      "afterBullet1": "Re-render child only when props change",
      "afterBullet2": "Reuse previous result",
      "afterBullet3": "Significantly improved performance",
      "afterUseMemo": "After Optimization (useMemo):",
      "reRenderEveryTime": "Child re-renders whenever parent changes",
      "noMatterPropsChange": "Regardless of prop changes",
      "unnecessaryReRender": "Performance degradation due to unnecessary renders",
      "onlyWhenPropsChange": "Re-render child only when props change",
      "reusePreviousResult": "Reuse previous result",
      "efficientPerformance": "Efficient performance",
      "recalculateEveryTime": "Execute calculation from scratch every time",
      "duplicateCalculation": "Duplicate calculations for same input",
      "wasteResources": "Degraded user experience",
      "firstCalculationOnly": "Calculate first time only, use cache afterwards",
      "recalculateWhenDepsChange": "Recalculate only when dependencies change",
      "saveCalculationTime": "Improved UX with instant response",
      "listenerKeepStacking": "Event listeners keep stacking",
      "notRemovedFromMemory": "Not removed from memory",
      "memoryLeakOccur": "Memory leak occurs!",
      "oneListener": "Maintain only one listener",
      "prevListenerRemove": "Previous listener is removed",
      "efficientMemory": "Efficient memory management",
      "title": "How It Works"
    },
    "performanceComparisonResult": "Performance Comparison Result",
    "noInput": "No input yet",
    "noneYet": "None yet",
    "reactMemoDemoTitle": "React.memo Demo",
    "renderingOptimizationGuide": "Rendering Optimization Guide",
    "realtimeFeedback": "Real-time Feedback",
    "demoBox": {
      "uiResponsivenessOptimization": "UI Responsiveness Optimization",
      "memoryManagementOptimization": "Memory Management Optimization",
      "keyMetrics": "Key Performance Metrics",
      "renderCountOptimization": "Render Count Optimization",
      "executionTimeOptimization": "Execution Time Optimization"
    },
    "uiResponsiveness": {
      "title": "UI Responsiveness Optimization",
      "description": "Ensure immediate response to user input.",
      "memo": {
        "desc": "Maintain responsiveness by separating heavy operations from UI updates."
      },
      "beforeOptimization": "Before Optimization",
      "afterOptimization": "After Optimization",
      "typingTest": "Typing Test",
      "heavyCalculation": "Heavy Calculation",
      "runHeavyCalculation": "Run Heavy Calculation",
      "changeTheme": "Change Theme",
      "charactersTyped": "Characters typed",
      "msDelay": "ms delay",
      "inputPlaceholder": "Try typing...",
      "nonOptimized": {
        "desc": "Dots keep flickering"
      },
      "optimized": {
        "desc": "Dots stay fixed"
      },
      "noInput": "No input yet",
      "core": "The core of UI optimization: ",
      "coreDesc": "Separate heavy calculations from UI updates using useMemo.",
      "drawDotsEveryType": "Draw dots every time you type",
      "unnecessaryDOMManipulation": "Unnecessary DOM manipulation",
      "laggyInputExperience": "Laggy input experience",
      "dotsNotRedrawn": "Dots not redrawn",
      "onlyNecessaryUpdates": "Only necessary updates",
      "smoothTypingExperience": "Smooth typing experience",
      "redrawEveryTyping": "Redraw every typing"
    },
    "memoryManagement": {
      "title": "Memory Management Optimization",
      "description": "Prevent memory leaks and manage efficiently.",
      "memo": {
        "desc": "Prevent memory leaks by properly cleaning up event listeners and timers."
      },
      "useMemoCore": "Core of useEffect cleanup: ",
      "useMemoDesc": "Prevent memory leaks with useEffect cleanup. Keeping unused items in memory slows down the app.",
      "createListener": "Create Listener",
      "removeListener": "Remove Listener",
      "listenerCount": "",
      "memoryLeakWarning": "Remains in memory after removal (Memory Leak!)",
      "properCleanup": "Completely removed with cleanup (efficient)",
      "accumulatedListeners": "Accumulated Listeners",
      "currentListeners": "Current Listeners",
      "keepStacking": "Keep stacking in memory",
      "actuallyInUse": "Only what's actually in use",
      "memoryLeakOccured": " memory leaks occurred!",
      "beforeOptimization": "Before Optimization",
      "afterOptimization": "After Optimization",
      "listenerAddedNotRemoved": "Listener Added (Not Removed)",
      "listenerManagedWithCleanup": "Listener Managed (Cleanup)",
      "noCleanupWarning": "‚ö†Ô∏è No Cleanup: {count} memory leaks!",
      "noCleanup": "No Cleanup",
      "withCleanup": "With Cleanup",
      "cleanupOnUnmount": "Cleaned on unmount",
      "cleanResourceCleanup": "Clean resource cleanup",
      "add": "Add",
      "remove": "Remove",
      "activeListeners": "Active Listeners",
      "memoryStatusMonitoring": "Memory Status Monitoring",
      "nonOptimized": {
        "desc": "Keeps stacking in memory"
      },
      "optimized": {
        "desc": "Only what's in use"
      },
      "none": "None yet",
      "explanation": "Proper cleanup prevents memory leaks and ensures optimal performance."
    },
    "code": {
      "comment": {
        "memoExample": "Only calculate when deps change",
        "expensiveCalculation": "Heavy calculation function (for performance testing)"
      }
    },
    "reactMemo": {
      "core": "The core of React.memo: ",
      "coreDesc": "Remember component render results and only re-render when props change.",
      "detailedExplanation": "React.memo is a <strong>Higher Order Component (HOC)</strong> that compares the previous props with the new props (shallow comparison) before rendering a component. If the props are the same, it <strong>skips rendering and reuses the previous result</strong>.",
      "countButton": "Count Button",
      "expensiveButton": "Expensive Button",
      "countButtonEffect": "üìä Count Button Effect",
      "expensiveButtonEffect": "üìä Expensive Button Effect",
      "countClicked": " times clicked",
      "propsChanged": "Props changed!",
      "interactive": "Interactive Test",
      "clickCountMultiple": "Click the Count button multiple times",
      "checkRenderCount": "Check that Render Count doesn't change",
      "clickExpensive": "Click the Expensive button",
      "checkRenderIncrease": "Check that Render Count increases",
      "howItWorks": "How does it work?",
      "magic": "React.memo's magic: ",
      "useMemoExecutionCount": "useMemo execution count",
      "parentOnlyRerendered": "Only parent re-rendered",
      "countButtonTitle": "Count Button Effect:",
      "countButtonBullet1": "Parent component re-renders",
      "countButtonBullet2": "Props don't change (expensiveValue stays the same)",
      "countButtonBullet3": "Child component doesn't re-render",
      "expensiveButtonTitle": "Expensive Button Effect:",
      "expensiveButtonBullet1": "Parent component re-renders",
      "expensiveButtonBullet2": "Props change (expensiveValue changes)",
      "expensiveButtonBullet3": "Child component re-renders",
      "notClickedYet": "Not clicked yet",
      "countChangedExpensiveValueSame": "count changed but expensiveValue remains the same ‚Üí Child not re-rendered",
      "expensiveValueChangedUseMemoRerun": "expensiveValue changed ‚Üí useMemo re-executed",
      "coreExplanation": "React.memo prevents unnecessary re-renders by memoizing component results.",
      "tryItBelow": "Try it below!",
      "parentChildBothRerendered": "Parent & child both re-rendered"
    },
    "testGuide": {
      "title": "Test Guide",
      "step1": "First click the Count button 5 times",
      "step2": "Check that the child component doesn't re-render",
      "step3": "Next click the Expensive button",
      "step4": "Check that the child component re-renders"
    },
    "useMemo": {
      "guideTitle": "useMemo Usage Guide",
      "guideDescription": "Use useMemo to memoize expensive calculations. It recalculates only when dependencies change.",
      "consoleMessage": "Check the console! You can see when useMemo actually executes.",
      "performanceTip": "üí° Performance Tip",
      "performanceTipDesc": "When you change the input value, it recalculates every time. But when you click the Count button, the previous calculation result is reused!"
    },
    "guide": {
      "goodExample": "‚úÖ Good Example",
      "useUniqueId": "Use unique ID as key",
      "badExample": "‚ùå Bad Example",
      "useArrayIndex": "Use array index as key",
      "keyPointTitle": "üí° Key Point",
      "keyPointDesc": "Using unique IDs as keys helps React efficiently track and update list items. Using indexes can cause issues when the list order changes."
    },
    "testIt": "Test it!",
    "dotsBlinking": "Dots blinking",
    "dotsFixed": "Dots fixed"
  },
  "serverComponents": {
    "title": "Server Components",
    "benefits": {
      "title": "Benefits of Server Components",
      "zeroBundle": {
        "desc": "Server component code is not sent to the client",
        "value": "Zero Bundle Size"
      },
      "directBackend": {
        "desc": "Direct access to database or file system",
        "value": "Direct Backend Access"
      },
      "autoCodeSplitting": {
        "desc": "Client components are automatically code-split",
        "value": "Automatic Code Splitting"
      },
      "improvedSecurity": {
        "desc": "Sensitive data or logic is not exposed to the client",
        "value": "Improved Security"
      }
    },
    "code": {
      "serverComponent": "Server Component Example",
      "clientComponent": "Client Component Example"
    }
  },
  "suspense": {
    "title": "Suspense & Error Boundaries",
    "suspense": {
      "title": "Suspense",
      "description": "Allows components to 'wait' for something before rendering",
      "usage": "Used for data loading, code splitting, image loading, etc."
    },
    "errorBoundary": {
      "title": "Error Boundary",
      "description": "Catch and handle JavaScript errors in child component tree",
      "usage": "Used for displaying error UI, error logging, recovery attempts, etc."
    },
    "code": {
      "suspenseExample": "Suspense Usage Example",
      "errorBoundaryExample": "Error Boundary Usage Example"
    }
  },
  "concurrent": {
    "title": "Concurrent Features",
    "features": {
      "useTransition": {
        "title": "useTransition",
        "description": "Maintain UI responsiveness by deferring non-urgent updates"
      },
      "useDeferredValue": {
        "title": "useDeferredValue",
        "description": "Optimize performance by deferring value updates"
      },
      "startTransition": {
        "title": "startTransition",
        "description": "Lower update priority to process important updates first"
      }
    },
    "code": {
      "transitionExample": "useTransition Example",
      "deferredExample": "useDeferredValue Example"
    }
  },
  "rules": {
    "title": "Rules of Hooks",
    "rule1": {
      "title": "1. Only Call at the Top Level",
      "description": "Don't call Hooks inside loops, conditions, or nested functions."
    },
    "rule2": {
      "title": "2. Only Call from React Functions",
      "description": "Call Hooks only from React function components or custom Hooks."
    }
  },
  "transition": {
    "loading": "Loading translations...",
    "pleaseWait": "Please wait a moment"
  },
  "react19": {
    "title": "React 19",
    "subtitle": "New Features",
    "newFeatures": {
      "title": "New Features in React 19",
      "description": "React 19 introduces groundbreaking features that significantly improve performance and developer experience."
    },
    "actionsAndUseTransition": {
      "subtitle": "Revolutionary async state management",
      "value": "Actions and useTransition"
    },
    "actions": {
      "description": "<strong>Actions</strong> are one of React 19's most innovative features, making form submissions and data mutations simple. ",
      "autoManagement": "They automatically handle pending states, errors, and optimistic updates."
    },
    "newWay": "// The new React 19 way",
    "formActionsAndUseActionState": {
      "subtitle": "A paradigm shift in form handling",
      "value": "Form Actions and useActionState"
    },
    "formActions": {
      "withUseActionState": "<strong>useActionState</strong> tracks and manages the state of form actions. ",
      "simplifiedDesc": "Form submission, loading states, and error handling all become simple with one Hook."
    },
    "useHook": {
      "subtitle": "A new way for Promises and Context",
      "value": "use Hook"
    },
    "use": {
      "description": "<strong>use</strong> is a new Hook that can read Promises or Context in components. "
    },
    "code": {
      "comment": {
        "conditionPromise": "Conditionally read a Promise",
        "conditionUse": "Can call use conditionally",
        "safePredict": "Safer and more predictable code",
        "formStatus": "Easily track form status",
        "optimistic": "Implement optimistic updates",
        "preinit": "Preinitialize scripts",
        "preload": "Preload resources",
        "prefetch": "Prefetch DNS",
        "preconnect": "Preconnect",
        "autoMemo": "Automatically memoized",
        "autoCallback": "Automatically useCallback",
        "autoMemoComponent": "No need for React.memo"
      },
      "beforeReact19": "Before React 19",
      "withReact19": "With React 19"
    },
    "useFormStatusAndUseOptimistic": {
      "subtitle": "Hooks for better user experience",
      "value": "useFormStatus and useOptimistic"
    },
    "formHooks": {
      "description": "These Hooks let you <strong>track form state in real-time</strong> and easily implement <strong>optimistic updates</strong>."
    },
    "newFormHooks": "// New Form Hooks",
    "serverComponentsAndReactCompiler": {
      "subtitle": "A new dimension of performance optimization",
      "value": "Server Components and React Compiler"
    },
    "compiler": {
      "description": "<strong>React Compiler</strong> automatically optimizes your components. "
    },
    "noLongerNeeded": "// No longer needed!",
    "resourcePreloadingAPIs": {
      "subtitle": "Faster page loading",
      "value": "Resource Preloading APIs"
    },
    "resources": {
      "description": "New resource APIs let you preload <strong>scripts, stylesheets, and fonts</strong>."
    },
    "newResourceAPIs": "// New Resource APIs",
    "upgrade": {
      "guideTitle": "React 19 Upgrade Guide",
      "step1": {
        "desc": "First upgrade to React 18.3.0",
        "value": "Step 1:"
      },
      "step2": {
        "desc": "Resolve StrictMode warnings",
        "value": "Step 2:"
      },
      "step3": {
        "desc": "Upgrade to TypeScript 5.1+",
        "value": "Step 3:"
      },
      "step4": {
        "desc": "Upgrade to React 19",
        "value": "Step 4:"
      },
      "step5": {
        "desc": "Gradually adopt new features",
        "value": "Step 5:"
      },
      "tip": "React Compiler is optional. Your existing code will work just fine!"
    }
  },
  "touch": {
    "scrollHint": "‚Üê Swipe to see more ‚Üí",
    "useTip": {
      "title": "Touch Tips",
      "gesture": "Use gestures for natural interaction",
      "tab": "Tap buttons to trigger actions",
      "pinch": "Pinch to zoom in demos",
      "drag": "Drag to reorder items"
    },
    "noGesture": "No gesture detected",
    "swipeHint": "Swipe in any direction",
    "rightSwipe": "Swiped Right ‚Üí",
    "leftSwipe": "‚Üê Swiped Left",
    "downSwipe": "Swiped Down ‚Üì",
    "upSwipe": "Swiped Up ‚Üë",
    "tap": "Tapped!",
    "swipeRightTo": "Swipe right to go back ‚Üí",
    "swipeLeftTo": "‚Üê Swipe left to continue",
    "swipeDownTo": "Swipe down to refresh ‚Üì",
    "swipeUpTo": "Swipe up for more ‚Üë",
    "click": "Click to interact",
    "touch": "Touch",
    "touchGestureHint": "Try tapping or swiping",
    "swipeOrDragHint": "Swipe or drag to interact",
    "pinch": "Pinch",
    "scale": "Scale",
    "pinchHint": "Pinch to zoom in/out",
    "drag": "Drag",
    "dragHint": "Drag the circle around",
    "touchMouseSupport": "Supports both touch and mouse"
  }
}
