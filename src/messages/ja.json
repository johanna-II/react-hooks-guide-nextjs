{
  "hero": {
    "title": "HOOKS",
    "subtitle": "Reactの<span>未来</span>に出会う",
    "description": "React Hooksのすべてを学び、React 19の革新的な機能を体験してください。リアルタイムデモ付きのインタラクティブな学習ガイドです。"
  },
  "navigation": {
    "home": "ホーム",
    "hooks": "React Hooks",
    "optimization": "最適化",
    "patterns": "高度なパターン"
  },
  "common": {
    "loading": "読み込み中...",
    "error": "エラーが発生しました",
    "retry": "もう一度試す",
    "close": "閉じる",
    "open": "開く",
    "save": "保存",
    "cancel": "キャンセル",
    "delete": "削除",
    "edit": "編集",
    "add": "追加",
    "search": "検索",
    "filter": "フィルター",
    "sort": "並び替え",
    "reset": "リセット",
    "submit": "送信",
    "back": "戻る",
    "next": "次へ",
    "previous": "前へ",
    "confirm": "確認",
    "yes": "はい",
    "no": "いいえ"
  },
  "guide": {
    "completeGuide": "完全ガイド",
    "hooksRules": "📋 Hooksの使用ルール",
    "whyHooksNeeded": "🚀 Hooksが必要な理由",
    "beginnerTitle": "🎯 初心者のためのReact Hooks完全ガイド",
    "whatIsHook": "Hookとは？",
    "whatIsHookDesc": "Hookは関数コンポーネントでReactの状態とライフサイクル機能を使用できるようにする関数です。クラスコンポーネントなしでReactのすべての機能を活用できます。",
    "whyUseHooks": "なぜHookを使うのか？",
    "whyUseHooksDesc": "Hookを使用すると、コンポーネント間で状態ロジックを簡単に再利用でき、複雑なコンポーネントをより理解しやすくなります。",
    "hookAdvantages": "Hookの利点",
    "hookAdvantagesDesc": "クラスコンポーネントのthisバインディングの問題がなく、コンポーネントを小さな関数に分割してテストしやすくなります。",
    "hookAdvantagesDesc.short": "コンポーネントを小さな関数に分割してテストしやすくなります。"
  },
  "hooks": {
    "useState": {
      "title": "useState",
      "description": "コンポーネントの状態を管理する最も基本的なHookです。",
      "descriptionDetail": "コンポーネントに状態を追加するHookです。"
    },
    "useEffect": {
      "title": "useEffect",
      "description": "副作用を実行し、ライフサイクルを管理します。",
      "descriptionDetail": "コンポーネントのライフサイクルに関連するタスクを処理するHookです。"
    },
    "useCallback": {
      "title": "useCallback",
      "description": "関数をメモ化して不要な再作成を防ぎます。",
      "descriptionDetail": "関数をメモ化して不要な再レンダリングを防ぎます。"
    },
    "useMemo": {
      "title": "useMemo",
      "description": "計算コストの高い値をメモ化します。",
      "descriptionDetail": "計算結果をメモ化してパフォーマンスを最適化します。"
    },
    "useRef": {
      "title": "useRef",
      "description": "DOM要素や値への参照を保持します。",
      "descriptionDetail": "DOM要素に直接アクセスしたり、値を保存したりするHookです。"
    },
    "codeExample": "コード例",
    "realTimeDemo": "リアルタイムデモ",
    "typeSomething": "何か入力してください...",
    "effectRunCount": "Effect実行回数",
    "browserTabNotice": "ブラウザのタブタイトルが変わるのを確認してください！",
    "clickToFocus": "ボタンをクリックしてフォーカスしてください...",
    "focusCount": "フォーカス回数",
    "renderCount": "レンダリング回数",
    "optimizationTip": "useCallbackで関数がメモ化され、不要な再レンダリングを防ぎます！",
    "valueA": "値 A",
    "valueB": "値 B",
    "calculationResult": "計算結果",
    "calculationCount": "計算実行回数",
    "memoTip": "AまたはBが変更されたときのみ計算が実行されます！"
  },
  "demo": {
    "title": "デモ",
    "description": "実際に動作する例を確認してください",
    "runDemo": "デモを実行",
    "viewCode": "コードを見る",
    "result": "結果",
    "useState": {
      "title": "useState デモ",
      "description": "状態管理の基本",
      "tip": "ボタンをクリックするとカウントが増加します"
    },
    "useEffect": {
      "title": "useEffect デモ",
      "description": "ライフサイクルと副作用",
      "tip": "入力するたびにEffectが実行されます"
    },
    "useCallback": {
      "title": "useCallback デモ",
      "description": "関数のメモ化",
      "tip": "expensiveValueが変更されない限り、子コンポーネントは再レンダリングされません"
    },
    "useMemo": {
      "title": "useMemo デモ",
      "description": "値のメモ化",
      "tip": "値AまたはBが変更されたときのみ計算が実行されます"
    },
    "useRef": {
      "title": "useRef デモ",
      "description": "DOM参照と値の保存",
      "tip": "Refはレンダリングを引き起こさずに値を保存します"
    },
    "count": "カウント",
    "increase": "増加",
    "typed": "入力済み",
    "increment": "増やす",
    "feedback": "フィードバック",
    "focusMePlaceholder": "フォーカスしてください！",
    "refCountDisplay": "Ref カウント: {count}",
    "focusInput": "入力欄にフォーカス",
    "incrementRef": "Refを増加",
    "showRefValue": "Ref値を表示",
    "refValueAlert": "現在のRef値: {value}"
  },
  "mobile": {
    "startButton": "始める",
    "swipeHint": "または左にスワイプ",
    "beginnerHooks": "初心者のためのReact Hooks",
    "meetFuture": "Reactの未来に出会う",
    "learnEverything": "React Hooksのすべてを学び、React 19の革新的な機能を体験してください。"
  },
  "form": {
    "title": "Form Actions デモ",
    "description": "このデモはReact 19の新しいForm Actions機能をシミュレートします。実際のForm ActionsではuseActionStateとuseFormStatusを使用します。",
    "formActions": {
      "code": "Form Actions コード",
      "example": "React 19の使用例です。"
    },
    "react19": {
      "benefits": "React 19の利点",
      "comparison": "従来の方法との違い"
    },
    "benefits": {
      "autoReset": "自動フォームリセット",
      "errorHandling": "組み込みエラー処理",
      "pendingState": "Pending状態の自動管理",
      "optimistic": "楽観的更新のサポート"
    },
    "comparison": {
      "noUseState": "useState + useEffectが不要",
      "noManualError": "手動エラー処理の削除",
      "simpleState": "複雑な状態管理の簡素化",
      "betterUX": "より良いユーザー体験"
    },
    "comment": {
      "actionStateUsage": "名前とメールアドレスの両方を入力してください。",
      "submitFailure": "送信に失敗しました。もう一度お試しください。"
    },
    "submit": {
      "preparing": "送信中...",
      "button": "フォームを送信"
    },
    "submitAria": "フォーム送信",
    "name": "名前",
    "email": "メールアドレス",
    "message": "メッセージ",
    "namePlaceholder": "名前を入力してください",
    "emailPlaceholder": "メールアドレスを入力してください",
    "messagePlaceholder": "メッセージを入力してください",
    "submit": "送信",
    "submitting": "送信中...",
    "successMessage": "フォームが正常に送信されました！",
    "errorMessage": "必須フィールドをすべて入力してください。",
    "required": "必須",
    "actionDescription": "<strong>useActionState</strong>と<strong>Form Actions</strong>でフォーム処理がはるかに簡単になりました。自動フォームリセット、エラー処理、pending状態を自動的に管理します。"
  },
  "whyHooks": {
    "title": "Hooksが必要な理由",
    "wrapperHell": {
      "title": "Wrapper Hell の解決",
      "desc": "HOCとRender Propsによる複雑なコンポーネントツリーを簡素化します。",
      "detail": "ロシア人形のように重なったコードを解きほぐしてきれいに整理します。"
    },
    "lifecycleSimplification": {
      "title": "ライフサイクルの簡素化",
      "desc": "複数のライフサイクルメソッドに散らばったロジックを一つのuseEffectに統合します。",
      "detail": "誕生、成長、消滅のような複雑なライフサイクルを一つの関数で簡単に管理します。"
    },
    "thisRemoval": {
      "title": "'this' の削除",
      "desc": "JavaScriptの混乱する'this'バインディングなしにクリーンな関数コンポーネントを作成します。",
      "detail": "「私」が誰なのか混乱することなく、明確にコードを書くことができます。"
    },
    "logicReuse": {
      "title": "ロジックの再利用",
      "desc": "カスタムフックで状態関連のロジックを簡単に再利用・共有できます。",
      "detail": "レゴブロックのように必要な機能を組み立て、他のプロジェクトでも同じように使用できます。"
    },
    "typescriptFriendly": {
      "title": "TypeScript フレンドリー",
      "desc": "型推論とジェネリックを活用して型安全なコードを作成できます。",
      "detail": "ランタイムエラーをコンパイル時に事前に捕捉し、より安定したアプリケーションを構築できます。"
    },
    "performanceOptimization": {
      "title": "パフォーマンス最適化",
      "desc": "React.memo、useMemo、useCallbackで不要な再レンダリングを防ぎます。",
      "detail": "メモ化により計算結果を再利用し、ユーザー体験を大幅に向上させます。"
    },
    "items": {
      "stateful": {
        "title": "状態ロジックの再利用",
        "desc": "HOCやrender propsなしでコンポーネント間で状態ロジックを簡単に共有"
      },
      "simpleComponents": {
        "title": "よりシンプルなコンポーネント",
        "desc": "関数コンポーネントはクラスコンポーネントより理解とテストが簡単"
      },
      "bundleSize": {
        "title": "バンドルサイズの改善",
        "desc": "関数コンポーネントはクラスコンポーネントより効率的にミニファイ"
      },
      "noBinding": {
        "title": "バインディング問題の解決",
        "desc": "イベントハンドラーで'this'バインディングを心配する必要がない"
      },
      "composition": {
        "title": "より良い構成",
        "desc": "Hookを通じて一つのコンポーネントをより小さな関数に分割可能"
      },
      "futureReady": {
        "title": "未来への準備",
        "desc": "Reactチームは新機能を関数コンポーネントに集中"
      }
    }
  },
  "optimization": {
    "metrics": {
      "title": "主要パフォーマンス指標",
      "description": "パフォーマンス最適化を理解するために知っておくべき重要な指標について説明します。"
    },
    "renderCount": {
      "title": "レンダリング回数の最適化",
      "description": "不要なレンダリングを防いでパフォーマンスを向上させます。",
      "memo": {
        "desc": "propsが変更されていない場合、コンポーネントは再レンダリングされません。"
      },
      "improvement": "回の不要なレンダリングを防止！",
      "test": "テストしてみてください！",
      "beforeOptimization": "最適化前",
      "afterOptimization": "最適化後 (React.memo)",
      "parentInefficient": "親が変わるたびに子も再描画 (非効率)",
      "propsReuseEfficient": "Propsが同じなら再利用 (効率的) - React 19では自動！"
    },
    "executionTime": {
      "title": "実行時間の最適化",
      "description": "コストの高い計算をメモ化します。",
      "memo": {
        "desc": "依存関係が変更されていない場合、再計算しません。"
      },
      "improvement": "% パフォーマンス向上！",
      "recalculationEveryTime": "毎回再計算",
      "cachedResults": "キャッシュされた結果を使用",
      "calculatePrime": "素数を計算",
      "calculateNow": "今すぐ計算",
      "calculationTime": "ミリ秒",
      "slowCalculation": "大きな素数判定を毎回再計算 (遅い)",
      "fastCalculation": "一度計算してキャッシュを使用 (速い)",
      "performanceComparisonResult": "パフォーマンス比較結果",
      "cachePerformance": "キャッシュパフォーマンスの向上",
      "beforeOptimization": "最適化前",
      "afterOptimization": "最適化後 (useMemo)",
      "primeSlow": "大きな素数判定を毎回再計算 (遅い)",
      "cacheUseFast": "一度計算してキャッシュを使用 (速い)",
      "cacheUse": "キャッシュ使用"
    },
    "uiResponsiveness": {
      "title": "UIレスポンシブ性の最適化",
      "description": "ユーザー入力への即座の応答を保証します。",
      "memo": {
        "desc": "重い操作とUI更新を分離してレスポンシブ性を維持します。"
      },
      "beforeOptimization": "最適化前",
      "afterOptimization": "最適化後",
      "typingTest": "タイピングテスト",
      "heavyCalculation": "重い計算",
      "runHeavyCalculation": "重い計算を実行",
      "changeTheme": "テーマを変更",
      "charactersTyped": "入力された文字数",
      "msDelay": "ms 遅延",
      "inputPlaceholder": "タイピングしてみてください...",
      "nonOptimized": {
        "desc": "ドットが点滅し続ける"
      },
      "optimized": {
        "desc": "ドットが固定される"
      },
      "noInput": "まだ入力なし"
    },
    "memoryManagement": {
      "title": "メモリ管理の最適化",
      "description": "メモリリークを防ぎ、効率的に管理します。",
      "memo": {
        "desc": "イベントリスナーとタイマーを適切にクリーンアップしてメモリリークを防ぎます。"
      },
      "useMemoCore": "useEffectクリーンアップの核心: ",
      "useMemoDesc": "useEffectクリーンアップでメモリリークを防ぎます。使用していないものをメモリに保持し続けるとアプリが遅くなります。",
      "createListener": "リスナーを作成",
      "removeListener": "リスナーを削除",
      "listenerCount": "個",
      "memoryLeakWarning": "削除してもメモリに残る (メモリリーク！)",
      "properCleanup": "クリーンアップで完全に削除 (効率的)",
      "accumulatedListeners": "蓄積されたリスナー",
      "currentListeners": "現在のリスナー",
      "keepStacking": "メモリに蓄積し続ける",
      "actuallyInUse": "実際に使用中のもののみ",
      "memoryLeakOccured": "個のメモリリークが発生！",
      "beforeOptimization": "最適化前",
      "afterOptimization": "最適化後",
      "listenerAddedNotRemoved": "リスナー追加 (削除なし)",
      "listenerManagedWithCleanup": "リスナー管理 (クリーンアップ)",
      "noCleanupWarning": "⚠️ クリーンアップなし: {count}個のメモリリーク！",
      "noCleanup": "クリーンアップなし",
      "withCleanup": "クリーンアップあり",
      "cleanupOnUnmount": "アンマウント時にクリーンアップ",
      "cleanResourceCleanup": "きれいなリソースクリーンアップ",
      "add": "追加",
      "remove": "削除",
      "activeListeners": "アクティブリスナー",
      "memoryStatusMonitoring": "メモリ状態の監視",
      "nonOptimized": {
        "desc": "メモリに蓄積し続ける"
      },
      "optimized": {
        "desc": "使用中のもののみ"
      },
      "none": "まだなし"
    }
  },
  "advanced": {
    "title": "高度なパターン",
    "description": "Reactの強力な機能を活用した高度なパターンを学びましょう。",
    "formActions": {
      "title": "Form Actions",
      "description": "React 19の新しいフォーム処理方法"
    },
    "serverComponents": {
      "title": "サーバーコンポーネント",
      "description": "サーバーで実行されるReactコンポーネント"
    },
    "suspense": {
      "title": "Suspense & エラーバウンダリ",
      "description": "非同期状態とエラー処理"
    },
    "concurrentFeatures": {
      "title": "並行機能",
      "description": "React 18+ の並行機能"
    }
  },
  "serverComponents": {
    "title": "サーバーコンポーネント",
    "benefits": {
      "title": "サーバーコンポーネントの利点",
      "zeroBundle": "ゼロバンドルサイズ",
      "zeroBundle.desc": "サーバーコンポーネントのコードはクライアントに送信されません",
      "directBackend": "直接的なバックエンドアクセス",
      "directBackend.desc": "データベースやファイルシステムに直接アクセス可能",
      "autoCodeSplitting": "自動コード分割",
      "autoCodeSplitting.desc": "クライアントコンポーネントは自動的にコード分割されます",
      "improvedSecurity": "セキュリティの向上",
      "improvedSecurity.desc": "機密データやロジックがクライアントに公開されません"
    },
    "code": {
      "serverComponent": "サーバーコンポーネントの例",
      "clientComponent": "クライアントコンポーネントの例"
    }
  },
  "suspense": {
    "title": "Suspense & エラーバウンダリ",
    "suspense": {
      "title": "Suspense",
      "description": "コンポーネントがレンダリング前に何かを「待つ」ことができる機能",
      "usage": "データロード、コード分割、画像ロードなどに使用"
    },
    "errorBoundary": {
      "title": "エラーバウンダリ",
      "description": "子コンポーネントツリーでJavaScriptエラーをキャッチして処理",
      "usage": "エラーUI表示、エラーロギング、復旧試行などに使用"
    },
    "code": {
      "suspenseExample": "Suspense使用例",
      "errorBoundaryExample": "エラーバウンダリ使用例"
    }
  },
  "concurrent": {
    "title": "並行機能",
    "features": {
      "useTransition": {
        "title": "useTransition",
        "description": "緊急でない更新を遅延させてUIの反応性を維持"
      },
      "useDeferredValue": {
        "title": "useDeferredValue",
        "description": "値の更新を遅延させてパフォーマンスを最適化"
      },
      "startTransition": {
        "title": "startTransition",
        "description": "更新の優先度を下げて重要な更新を先に処理"
      }
    },
    "code": {
      "transitionExample": "useTransition例",
      "deferredExample": "useDeferredValue例"
    }
  },
  "rules": {
    "title": "Hooksの使用ルール",
    "rule1": {
      "title": "1. トップレベルでのみ呼び出す",
      "description": "ループ、条件文、ネストされた関数内でHookを呼び出さないでください。"
    },
    "rule2": {
      "title": "2. React関数からのみ呼び出す",
      "description": "React関数コンポーネントまたはカスタムフックからのみHookを呼び出してください。"
    }
  },
  "transition": {
    "loading": "翻訳を読み込んでいます...",
    "pleaseWait": "しばらくお待ちください"
  },
  "react19": {
    "newFeatures": {
      "title": "React 19の新機能",
      "description": "React 19は、パフォーマンスと開発者体験を大幅に向上させる革新的な機能を導入します。"
    },
    "actionsAndUseTransition": "Actionsとu1seTransition",
    "actionsAndUseTransition.subtitle": "非同期状態管理の革新",
    "actions": {
      "description": "<strong>Actions</strong>はReact 19の最も革新的な機能の1つで、フォーム送信とデータ変更を簡単に処理できます。",
      "autoManagement": "pending状態、エラー処理、楽観的更新を自動的に管理します。"
    },
    "newWay": "// React 19の新しい方法",
    "formActionsAndUseActionState": "Form ActionsとuseActionState",
    "formActionsAndUseActionState.subtitle": "フォーム処理のパラダイムシフト",
    "formActions": {
      "withUseActionState": "<strong>useActionState</strong>はフォームアクションの状態を追跡・管理します。",
      "simplifiedDesc": "フォーム送信、ローディング状態、エラー処理がすべて1つのHookでシンプルになります。"
    },
    "useHook": "use Hook",
    "useHook.subtitle": "PromiseとContextの新しい方法",
    "use": {
      "description": "<strong>use</strong>はコンポーネントでPromiseやContextを読み込める新しいHookです。"
    },
    "code": {
      "comment": {
        "conditionPromise": "条件付きでPromiseを読み込む",
        "conditionUse": "条件付きでuseを呼び出し可能",
        "safePredict": "より安全で予測可能なコード",
        "formStatus": "フォームステータスを簡単に追跡",
        "optimistic": "楽観的更新を実装",
        "preinit": "スクリプトを事前初期化",
        "preload": "リソースを事前ロード",
        "prefetch": "DNSプリフェッチ",
        "preconnect": "事前接続"
      },
      "beforeReact19": "React 19以前",
      "withReact19": "React 19",
      "comment.autoMemo": "自動的にメモ化",
      "comment.autoCallback": "自動的にuseCallback",
      "comment.autoMemoComponent": "React.memo不要"
    },
    "useFormStatusAndUseOptimistic": "useFormStatusとuseOptimistic",
    "useFormStatusAndUseOptimistic.subtitle": "より良いユーザー体験のためのHook",
    "formHooks": {
      "description": "これらのHookは<strong>フォームの状態をリアルタイムで追跡</strong>し、<strong>楽観的更新</strong>を簡単に実装できます。"
    },
    "newFormHooks": "// 新しいForm Hooks",
    "serverComponentsAndReactCompiler": "Server ComponentsとReact Compiler",
    "serverComponentsAndReactCompiler.subtitle": "パフォーマンス最適化の新次元",
    "compiler": {
      "description": "<strong>React Compiler</strong>はコンポーネントを自動的に最適化します。"
    },
    "noLongerNeeded": "// もう必要ありません！",
    "resourcePreloadingAPIs": "リソースプリロードAPI",
    "resourcePreloadingAPIs.subtitle": "より高速なページ読み込み",
    "resources": {
      "description": "新しいリソースAPIで<strong>スクリプト、スタイルシート、フォント</strong>を事前ロードできます。"
    },
    "newResourceAPIs": "// 新しいリソースAPI",
    "upgrade": {
      "guideTitle": "React 19アップグレードガイド",
      "step1": "ステップ1:",
      "step1.desc": "まずReact 18.3.0にアップグレード",
      "step2": "ステップ2:",
      "step2.desc": "StrictMode警告を解決",
      "step3": "ステップ3:",
      "step3.desc": "TypeScript 5.1+にアップグレード",
      "step4": "ステップ4:",
      "step4.desc": "React 19にアップグレード",
      "step5": "ステップ5:",
      "step5.desc": "新機能を段階的に導入",
      "tip": "React Compilerはオプションです。既存のコードは正常に動作します！"
    }
  }
}
